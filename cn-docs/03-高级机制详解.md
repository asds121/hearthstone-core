# 炉石传说高级机制详解

## 概述

本文档深入分析炉石传说中的复杂机制和特殊规则，包括光环系统、扳机优先级、随机性处理、特殊交互等高级主题。

---

## 1. 光环系统深度解析

### 1.1 光环类型与实现

光环是炉石传说中最复杂的机制之一，它涉及持续性的状态修改和效果增强。

```typescript
// 光环接口
interface IAura {
    id: number;
    source: IEntity;
    type: AuraType;
    priority: number;
    
    // 光环生效条件
    condition?: (entity: IEntity) => boolean;
    
    // 光环效果
    apply(entity: IEntity): void;
    remove(entity: IEntity): void;
    
    // 光环更新
    update(): void;
}

// 光环类型枚举
enum AuraType {
    // 属性修改
    ATTACK = "ATTACK",
    HEALTH = "HEALTH",
    COST = "COST",
    
    // 关键字赋予
    KEYWORD = "KEYWORD",
    
    // 效果增强
    SPELL_DAMAGE = "SPELL_DAMAGE",
    HEALING_MULTIPLIER = "HEALING_MULTIPLIER",
    
    // 触发器
    TRIGGER_MULTIPLIER = "TRIGGER_MULTIPLIER"
}

// 具体光环实现
class AttackAura implements IAura {
    type = AuraType.ATTACK;
    priority = 0; // 光环优先级
    
    constructor(
        public id: number,
        public source: IEntity,
        public value: number,
        public condition?: (entity: IEntity) => boolean
    ) {}
    
    apply(entity: IEntity): void {
        if (this.condition && !this.condition(entity)) return;
        
        // 创建光环状态
        const enchantment = new EnchantmentEntity(
            `${this.source.id}_attack_aura`,
            entity,
            this.source
        );
        
        enchantment.tags.set(TagType.ATK, this.value);
        entity.enchantments.push(enchantment);
        
        // 应用属性修改
        entity.attack += this.value;
    }
    
    remove(entity: IEntity): void {
        // 移除光环状态
        const enchantment = entity.enchantments.find(e => 
            e.source.id === this.source.id && 
            e.tags.has(TagType.ATK)
        );
        
        if (enchantment) {
            const index = entity.enchantments.indexOf(enchantment);
            entity.enchantments.splice(index, 1);
            
            // 撤销属性修改
            entity.attack -= enchantment.tags.get(TagType.ATK) || 0;
        }
    }
    
    update(): void {
        // 光环更新逻辑
    }
}
```

### 1.2 光环优先级系统

```typescript
class AuraPriorityManager {
    // 光环优先级表
    private static priorityTable = new Map<string, number>([
        // 基础属性光环
        ['stormwind_champion', 1],     // 暴风城勇士
        ['murloc_warleader', 1],       // 鱼人领军
        
        // 特殊光环
        ['crystal_core', 0],           // 水晶核心（最高优先级）
        ['dark_pharaoh_tekahn', 0],    // 黑暗法老塔卡恒
        
        // 费用光环
        ['summoning_portal', 2],       // 召唤传送门
        ['mechwarper', 2],             // 机械跃迁者
        
        // 效果增强光环
        ['spell_damage', 3],           // 法术伤害
        ['prophet_velen', 4],          // 先知维伦
        
        // 触发器光环
        ['brann_bronzebeard', 5],      // 布莱恩·铜须
        ['baron_rivendare', 5],        // 瑞文戴尔男爵
    ]);
    
    static getAuraPriority(aura: IAura): number {
        const cardId = aura.source.cardId;
        return this.priorityTable.get(cardId) || 0;
    }
    
    static sortAuras(auras: IAura[]): IAura[] {
        return auras.sort((a, b) => {
            const aPriority = this.getAuraPriority(a);
            const bPriority = this.getAuraPriority(b);
            
            if (aPriority !== bPriority) {
                return aPriority - bPriority; // 优先级数值越小，优先级越高
            }
            
            // 相同优先级按入场顺序
            return a.source.id - b.source.id;
        });
    }
}
```

### 1.3 光环更新时机

```typescript
enum AuraUpdateTiming {
    PHASE_END = "PHASE_END",
    ENTITY_CREATED = "ENTITY_CREATED",
    ENTITY_ENTERED_PLAY = "ENTITY_ENTERED_PLAY",
    ENTITY_TRANSFORMED = "ENTITY_TRANSFORMED",
    ENTITY_AWAKENED = "ENTITY_AWAKENED",
    ENTITY_LEFT_PLAY = "ENTITY_LEFT_PLAY",
    ENTITY_CONTROL_CHANGED = "ENTITY_CONTROL_CHANGED"
}

class AuraUpdateManager {
    // 需要更新光环的时机
    private static updateTriggers = new Set([
        EventType.SUMMON,
        EventType.DEATH,
        EventType.TRANSFORM,
        EventType.CONTROL_CHANGE
    ]);
    
    static onEvent(event: IGameEvent): void {
        if (this.updateTriggers.has(event.type)) {
            this.scheduleAuraUpdate(event);
        }
    }
    
    private static scheduleAuraUpdate(event: IGameEvent): void {
        // 延迟到阶段结束时更新
        EventManager.enqueue({
            type: EventType.AURA_UPDATE,
            source: event.source,
            targets: event.targets,
            timestamp: Date.now(),
            data: {
                reason: event.type
            }
        });
    }
    
    static updateAurasForEntity(entity: IEntity): void {
        // 1. 移除过期的光环效果
        this.removeExpiredAuras(entity);
        
        // 2. 应用新的光环效果
        this.applyApplicableAuras(entity);
        
        // 3. 重新计算属性
        this.recalculateEntityStats(entity);
    }
    
    private static removeExpiredAuras(entity: IEntity): void {
        const expiredAuras = entity.enchantments.filter(e => {
            return e.source.zone !== ZoneType.PLAY || // 源实体不在战场
                   e.source.tags.get(TagType.TO_BE_DESTROYED); // 源实体待销毁
        });
        
        for (const aura of expiredAuras) {
            aura.remove(entity);
        }
    }
    
    private static applyApplicableAuras(entity: IEntity): void {
        const game = GameManager.getGame();
        const applicableAuras = [];
        
        // 收集所有适用的光环
        for (const player of game.players) {
            for (const minion of player.minions) {
                if (minion.aura && this.isAuraApplicable(minion.aura, entity)) {
                    applicableAuras.push(minion.aura);
                }
            }
        }
        
        // 按优先级排序并应用
        const sortedAuras = AuraPriorityManager.sortAuras(applicableAuras);
        for (const aura of sortedAuras) {
            aura.apply(entity);
        }
    }
    
    private static isAuraApplicable(aura: IAura, entity: IEntity): boolean {
        // 检查光环是否适用于该实体
        if (aura.condition && !aura.condition(entity)) {
            return false;
        }
        
        // 检查控制器
        if (aura.source.controller !== entity.controller && 
            !aura.affectsOpponent) {
            return false;
        }
        
        // 检查种族要求
        if (aura.requiredRace && entity.race !== aura.requiredRace) {
            return false;
        }
        
        return true;
    }
    
    private static recalculateEntityStats(entity: IEntity): void {
        // 重新计算实体属性
        if (entity.type === EntityType.MINION) {
            this.recalculateMinionStats(entity as MinionEntity);
        }
    }
    
    private static recalculateMinionStats(minion: MinionEntity): void {
        // 重置到基础值
        minion.attack = minion.baseAttack;
        minion.maxHealth = minion.baseHealth;
        
        // 应用所有状态
        for (const enchantment of minion.enchantments) {
            if (enchantment.tags.has(TagType.ATK)) {
                minion.attack += enchantment.tags.get(TagType.ATK);
            }
            if (enchantment.tags.has(TagType.HEALTH)) {
                minion.maxHealth += enchantment.tags.get(TagType.HEALTH);
            }
        }
        
        // 确保生命值不超过最大生命值
        minion.health = Math.min(minion.health, minion.maxHealth);
    }
}
```

---

## 2. 扳机优先级与排序

### 2.1 扳机排序系统

```typescript
class TriggerSorter {
    // 扳机优先级映射
    private static priorityMap = new Map<string, TriggerPriority>([
        // 最高优先级
        ['echo_disappear', TriggerPriority.HIGH],      // 回响消失
        ['unstable_evolution_disappear', TriggerPriority.HIGH], // 不稳定异变消失
        
        // 普通优先级
        ['normal', TriggerPriority.NORMAL],
        
        // 低优先级
        ['redemption', TriggerPriority.LOW],           // 救赎
        ['lifesteal', TriggerPriority.LOW],            // 吸血
        ['overkill', TriggerPriority.LOW],             // 超杀
        
        // 最低优先级
        ['reborn', TriggerPriority.LOWEST],            // 复生
    ]);
    
    static sortTriggers(triggers: ITrigger[], event: IGameEvent): ITrigger[] {
        return triggers.sort((a, b) => {
            // 1. 按优先级排序
            const aPriority = this.getTriggerPriority(a);
            const bPriority = this.getTriggerPriority(b);
            
            if (aPriority !== bPriority) {
                return aPriority - bPriority;
            }
            
            // 2. 按区域排序
            const aZoneOrder = this.getZoneOrder(a.entity.zone);
            const bZoneOrder = this.getZoneOrder(b.entity.zone);
            
            if (aZoneOrder !== bZoneOrder) {
                return aZoneOrder - bZoneOrder;
            }
            
            // 3. 按入场顺序
            return a.entity.id - b.entity.id;
        });
    }
    
    private static getTriggerPriority(trigger: ITrigger): number {
        // 检查特殊优先级
        if (trigger.entity.cardId && this.priorityMap.has(trigger.entity.cardId)) {
            return this.priorityMap.get(trigger.entity.cardId)!;
        }
        
        // 检查扳机类型
        if (trigger.type === EventType.TURN_END && 
            trigger.entity.tags.has(TagType.ECHO)) {
            return TriggerPriority.HIGH;
        }
        
        // 默认优先级
        return TriggerPriority.NORMAL;
    }
    
    private static getZoneOrder(zone: ZoneType): number {
        switch (zone) {
            case ZoneType.PLAY: return 1;
            case ZoneType.SECRET: return 1;
            case ZoneType.HAND: return 2;
            case ZoneType.DECK: return 3;
            default: return 4;
        }
    }
}
```

### 2.2 特殊扳机处理

```typescript
// 秘密通道特殊处理
class SecretPassageHandler {
    private static passageStack: IEntity[] = [];
    
    static onSecretPassagePlayed(entity: IEntity): void {
        this.passageStack.push(entity);
    }
    
    static onTurnEnd(): void {
        // 按倒序处理秘密通道
        while (this.passageStack.length > 0) {
            const passage = this.passageStack.pop()!;
            this.processSecretPassageReturn(passage);
        }
    }
    
    private static processSecretPassageReturn(passage: IEntity): void {
        // 将卡牌归还到手牌
        const player = passage.controller;
        
        // 获取需要归还的卡牌
        const cardsToReturn = passage.tags.get(TagType.PASSAGE_CARDS) || [];
        
        for (const card of cardsToReturn) {
            if (player.hand.length < 10) {
                ZoneManager.moveEntity(card, ZoneType.HAND, player.id);
            } else {
                // 手牌已满，烧毁卡牌
                ZoneManager.moveEntity(card, ZoneType.GRAVEYARD);
            }
        }
    }
}

// 裂心者伊露希亚特殊处理
class IlluciaHandler {
    static onTurnEnd(): void {
        // 处理裂心者效果归还
        const game = GameManager.getGame();
        
        for (const player of game.players) {
            const illuciaEffect = player.tags.get(TagType.ILLUCIA_EFFECT);
            if (illuciaEffect) {
                this.processIlluciaReturn(player, illuciaEffect);
            }
        }
    }
    
    private static processIlluciaReturn(player: PlayerEntity, effect: any): void {
        // 归还手牌
        const originalHand = effect.originalHand;
        const currentHand = player.hand.slice();
        
        // 清除当前手牌
        for (const card of currentHand) {
            ZoneManager.moveEntity(card, ZoneType.SETASIDE);
        }
        
        // 恢复原始手牌
        for (const card of originalHand) {
            ZoneManager.moveEntity(card, ZoneType.HAND, player.id);
        }
    }
}
```

---

## 3. 随机性处理机制

### 3.1 随机目标选择

```typescript
class RandomTargetSelector {
    // 随机选择目标
    static selectRandomTarget(
        candidates: IEntity[], 
        filter?: (entity: IEntity) => boolean,
        count: number = 1
    ): IEntity[] {
        // 应用过滤器
        let filteredCandidates = candidates;
        if (filter) {
            filteredCandidates = candidates.filter(filter);
        }
        
        // 检查候选者数量
        if (filteredCandidates.length === 0) {
            return [];
        }
        
        if (count >= filteredCandidates.length) {
            return filteredCandidates;
        }
        
        // 随机选择
        const selected: IEntity[] = [];
        const available = [...filteredCandidates];
        
        for (let i = 0; i < count; i++) {
            const randomIndex = this.getRandomInt(0, available.length - 1);
            const selectedEntity = available.splice(randomIndex, 1)[0];
            selected.push(selectedEntity);
        }
        
        return selected;
    }
    
    // 随机伤害选择
    static selectRandomDamageTarget(candidates: IEntity[]): IEntity | null {
        // 忽略濒死角色
        const validTargets = candidates.filter(entity => 
            entity.health > 0 && 
            !entity.tags.get(TagType.MORTALLY_WOUNDED)
        );
        
        if (validTargets.length === 0) {
            return null;
        }
        
        const randomIndex = this.getRandomInt(0, validTargets.length - 1);
        return validTargets[randomIndex];
    }
    
    // 随机治疗选择
    static selectRandomHealTarget(candidates: IEntity[]): IEntity | null {
        // 忽略未受伤角色
        const validTargets = candidates.filter(entity => {
            if (entity.type === EntityType.HERO) {
                const hero = entity as HeroEntity;
                return hero.health < hero.maxHealth;
            } else if (entity.type === EntityType.MINION) {
                const minion = entity as MinionEntity;
                return minion.health < minion.maxHealth;
            }
            return false;
        });
        
        if (validTargets.length === 0) {
            return null;
        }
        
        const randomIndex = this.getRandomInt(0, validTargets.length - 1);
        return validTargets[randomIndex];
    }
    
    // 获取随机整数（可预测，用于回放）
    private static getRandomInt(min: number, max: number): number {
        const randomService = GameManager.getRandomService();
        return randomService.getRandomInt(min, max);
    }
}

// 随机服务（支持回放）
class RandomService {
    private seed: number;
    private sequence: number[] = [];
    private index = 0;
    private isRecording = false;
    
    constructor(seed?: number) {
        this.seed = seed || Date.now();
        
        if (!seed) {
            this.isRecording = true;
        }
    }
    
    getRandomInt(min: number, max: number): number {
        if (this.isRecording) {
            const value = Math.floor(Math.random() * (max - min + 1)) + min;
            this.sequence.push(value);
            return value;
        } else {
            // 回放模式
            if (this.index >= this.sequence.length) {
                throw new Error('Random sequence exhausted');
            }
            return this.sequence[this.index++];
        }
    }
    
    getSequence(): number[] {
        return [...this.sequence];
    }
    
    setSequence(sequence: number[]): void {
        this.sequence = [...sequence];
        this.index = 0;
        this.isRecording = false;
    }
}
```

---

## 4. 特殊交互机制

### 4.1 变形与复制

```typescript
// 变形系统
class TransformSystem {
    static transform(entity: IEntity, newCardId: string): IEntity {
        // 保留原始ID和入场时间
        const originalId = entity.id;
        const originalEntranceTime = entity.tags.get(TagType.NUM_TURNS_IN_PLAY);
        
        // 创建新实体
        const newEntity = EntityFactory.createEntity(newCardId);
        
        // 保留关键属性
        newEntity.id = originalId;
        newEntity.tags.set(TagType.NUM_TURNS_IN_PLAY, originalEntranceTime);
        newEntity.zone = entity.zone;
        newEntity.zonePosition = entity.zonePosition;
        newEntity.controller = entity.controller;
        
        // 保留部分状态
        this.retainRelevantEnchantments(entity, newEntity);
        
        // 替换实体
        ZoneManager.replaceEntity(entity, newEntity);
        
        // 触发变形事件
        EventManager.triggerEvent({
            type: EventType.TRANSFORM,
            source: entity,
            targets: [newEntity],
            timestamp: Date.now(),
            data: {
                fromCardId: entity.cardId,
                toCardId: newCardId
            }
        });
        
        return newEntity;
    }
    
    private static retainRelevantEnchantments(oldEntity: IEntity, newEntity: IEntity): void {
        // 保留某些光环效果
        for (const enchantment of oldEntity.enchantments) {
            if (this.shouldRetainEnchantment(enchantment)) {
                newEntity.enchantments.push(enchantment);
                enchantment.target = newEntity;
            }
        }
    }
    
    private static shouldRetainEnchantment(enchantment: IEntity): boolean {
        // 保留光环效果
        if (enchantment.tags.get(TagType.AURA)) {
            return true;
        }
        
        // 保留某些特殊效果
        const retainTags = [
            TagType.DIVINE_SHIELD,
            TagType.STEALTH,
            TagType.POISONOUS
        ];
        
        return retainTags.some(tag => enchantment.tags.has(tag));
    }
}

// 复制系统
class CopySystem {
    static copy(entity: IEntity, copier: IEntity): IEntity {
        // 创建复制
        const copy = EntityFactory.createEntity(entity.cardId);
        
        // 复制当前属性（不包括光环）
        copy.attack = entity.attack;
        copy.health = entity.health;
        copy.maxHealth = entity.maxHealth;
        copy.cost = entity.cost;
        
        // 复制状态（不包括光环）
        for (const enchantment of entity.enchantments) {
            if (!enchantment.tags.get(TagType.AURA)) {
                const enchantmentCopy = this.copyEnchantment(enchantment, copy, copier);
                copy.enchantments.push(enchantmentCopy);
            }
        }
        
        // 复制入场时间点（用于扳机排序）
        copy.tags.set(TagType.NUM_TURNS_IN_PLAY, 
                     entity.tags.get(TagType.NUM_TURNS_IN_PLAY));
        
        return copy;
    }
    
    private static copyEnchantment(
        original: IEntity, 
        target: IEntity, 
        source: IEntity
    ): IEntity {
        const copy = EntityFactory.createEnchantment(
            original.cardId,
            target,
            source
        );
        
        // 复制标签
        for (const [key, value] of original.tags) {
            copy.tags.set(key, value);
        }
        
        return copy;
    }
}
```

### 4.2 休眠机制

```typescript
// 休眠系统
class DormantSystem {
    static putToDormant(entity: IEntity, duration: number = 2): void {
        // 设置休眠状态
        entity.tags.set(TagType.DORMANT, 1);
        entity.tags.set(TagType.DORMANT_DURATION, duration);
        
        // 保留所有状态
        entity.tags.set(TagType.PRESERVE_ENCHANTMENTS, 1);
        
        // 触发休眠事件
        EventManager.triggerEvent({
            type: EventType.DORMANT,
            source: entity,
            targets: [entity],
            timestamp: Date.now(),
            data: {
                duration: duration
            }
        });
    }
    
    static awaken(entity: IEntity): void {
        // 清除休眠状态
        entity.tags.delete(TagType.DORMANT);
        entity.tags.delete(TagType.DORMANT_DURATION);
        
        // 添加召唤失调
        entity.tags.set(TagType.JUST_PLAYED, 1);
        entity.tags.set(TagType.EXHAUSTED, 1);
        
        // 触发苏醒事件
        EventManager.triggerEvent({
            type: EventType.AWAKEN,
            source: entity,
            targets: [entity],
            timestamp: Date.now()
        });
    }
    
    static processDormantEntities(): void {
        const game = GameManager.getGame();
        
        for (const player of game.players) {
            for (const minion of player.minions) {
                if (minion.tags.get(TagType.DORMANT)) {
                    const duration = minion.tags.get(TagType.DORMANT_DURATION) || 0;
                    const currentTurn = minion.tags.get(TagType.NUM_TURNS_IN_PLAY) || 0;
                    
                    if (currentTurn >= duration) {
                        this.awaken(minion);
                    }
                }
            }
        }
    }
}
```

---

## 5. 复杂效果组合

### 5.1 连锁效果

```typescript
// 连锁效果管理器
class ChainEffectManager {
    private static activeChains: EffectChain[] = [];
    
    static startChain(chain: EffectChain): void {
        this.activeChains.push(chain);
        this.processChain(chain);
    }
    
    static processChain(chain: EffectChain): void {
        // 递归处理连锁效果
        for (const effect of chain.effects) {
            const events = effect.execute();
            
            if (events && events.length > 0) {
                for (const event of events) {
                    EventManager.triggerEvent(event);
                }
            }
            
            // 检查是否需要继续连锁
            if (effect.shouldContinueChain()) {
                const nextChain = effect.getNextChain();
                if (nextChain) {
                    this.processChain(nextChain);
                }
            }
        }
    }
}

// 示例：尤格-萨隆连锁
class YoggSaronChain implements EffectChain {
    effects: IEffect[] = [];
    
    constructor(private player: PlayerEntity, private spellCount: number) {
        // 创建连锁效果
        for (let i = 0; i < Math.min(spellCount, 30); i++) {
            this.effects.push(new RandomSpellEffect(player));
        }
    }
}

class RandomSpellEffect implements IEffect {
    constructor(private player: PlayerEntity) {}
    
    execute(): IGameEvent[] {
        // 随机选择一个法术并施放
        const randomSpell = SpellLibrary.getRandomSpell();
        return randomSpell.execute(this.player);
    }
    
    shouldContinueChain(): boolean {
        // 尤格-萨隆有概率继续施放
        return Math.random() < 0.5;
    }
    
    getNextChain(): EffectChain | null {
        // 检查是否继续
        if (this.shouldContinueChain()) {
            return new YoggSaronChain(this.player, 1);
        }
        return null;
    }
}
```

### 5.2 条件效果

```typescript
// 条件效果基类
abstract class ConditionalEffect implements IEffect {
    protected condition: ICondition;
    protected trueEffect: IEffect;
    protected falseEffect?: IEffect;
    
    constructor(
        condition: ICondition,
        trueEffect: IEffect,
        falseEffect?: IEffect
    ) {
        this.condition = condition;
        this.trueEffect = trueEffect;
        this.falseEffect = falseEffect;
    }
    
    execute(context: EffectContext): IGameEvent[] {
        if (this.condition.evaluate(context)) {
            return this.trueEffect.execute(context);
        } else if (this.falseEffect) {
            return this.falseEffect.execute(context);
        }
        return [];
    }
}

// 具体条件效果
class IfHoldingDragonEffect extends ConditionalEffect {
    constructor(trueEffect: IEffect, falseEffect?: IEffect) {
        super(new HoldingDragonCondition(), trueEffect, falseEffect);
    }
}

class HoldingDragonCondition implements ICondition {
    evaluate(context: EffectContext): boolean {
        const player = context.player;
        return player.hand.some(card => card.race === Race.DRAGON);
    }
}
```

---

## 6. 性能优化策略

### 6.1 效果缓存

```typescript
class EffectCache {
    private static cache = new Map<string, any>();
    private static maxSize = 1000;
    
    static get(key: string): any {
        return this.cache.get(key);
    }
    
    static set(key: string, value: any): void {
        if (this.cache.size >= this.maxSize) {
            // LRU清理
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
    
    static clear(): void {
        this.cache.clear();
    }
    
    static generateKey(entity: IEntity, effect: string, context: any): string {
        return `${entity.id}_${effect}_${JSON.stringify(context)}`;
    }
}
```

### 6.2 批量处理

```typescript
class BatchProcessor {
    private static batch: IGameEvent[] = [];
    private static batchTimer: NodeJS.Timeout | null = null;
    
    static addToBatch(event: IGameEvent): void {
        this.batch.push(event);
        
        if (!this.batchTimer) {
            this.batchTimer = setTimeout(() => {
                this.processBatch();
            }, 0);
        }
    }
    
    private static processBatch(): void {
        // 按类型分组处理
        const groupedEvents = this.groupEventsByType(this.batch);
        
        for (const [type, events] of groupedEvents) {
            EventManager.processEvents(events);
        }
        
        this.batch = [];
        this.batchTimer = null;
    }
    
    private static groupEventsByType(events: IGameEvent[]): Map<EventType, IGameEvent[]> {
        const groups = new Map<EventType, IGameEvent[]>();
        
        for (const event of events) {
            if (!groups.has(event.type)) {
                groups.set(event.type, []);
            }
            groups.get(event.type)!.push(event);
        }
        
        return groups;
    }
}
```

---

## 7. 调试与测试

### 7.1 高级调试工具

```typescript
class AdvancedDebugger {
    static logAuraUpdate(entity: IEntity, oldStats: any, newStats: any): void {
        if (Config.debugAuras) {
            console.log(`[Aura Update] Entity: ${entity.id} (${entity.cardId})`);
            console.log(`  Attack: ${oldStats.attack} -> ${newStats.attack}`);
            console.log(`  Health: ${oldStats.health} -> ${newStats.health}`);
            console.log(`  Enchantments: ${entity.enchantments.length}`);
        }
    }
    
    static logTriggerExecution(trigger: ITrigger, event: IGameEvent): void {
        if (Config.debugTriggers) {
            console.log(`[Trigger] ${trigger.entity.cardId} triggered by ${event.type}`);
            console.log(`  Priority: ${trigger.priority}`);
            console.log(`  Entity Zone: ${trigger.entity.zone}`);
        }
    }
    
    static createAuraSnapshot(): AuraSnapshot {
        const game = GameManager.getGame();
        const snapshot: AuraSnapshot = {
            timestamp: Date.now(),
            auras: []
        };
        
        for (const player of game.players) {
            for (const minion of player.minions) {
                for (const enchantment of minion.enchantments) {
                    if (enchantment.tags.get(TagType.AURA)) {
                        snapshot.auras.push({
                            source: enchantment.source.id,
                            target: minion.id,
                            type: enchantment.tags.get(TagType.AURA_TYPE),
                            value: enchantment.tags.get(TagType.AURA_VALUE)
                        });
                    }
                }
            }
        }
        
        return snapshot;
    }
}
```

### 7.2 自动化测试

```typescript
class MechanicTestFramework {
    static testAuraPriority(): TestResult {
        const test = new GameTest();
        
        // 设置测试场景
        test.setupGame([
            { player: 1, cards: ['Stormwind Champion', 'Bloodfen Raptor'] },
            { player: 2, cards: ['Murloc Warleader', 'Murloc Raider'] }
        ]);
        
        // 执行操作
        test.playCard(1, 'Stormwind Champion');
        test.playCard(2, 'Murloc Warleader');
        
        // 验证结果
        const raptor = test.getEntity(1, 'Bloodfen Raptor');
        const raider = test.getEntity(2, 'Murloc Raider');
        
        // 检查光环优先级
        const expectedRaptorAttack = 4; // 3 + 1 (暴风城勇士)
        const expectedRaiderAttack = 3; // 2 + 1 (鱼人领军)
        
        return test.assert([
            () => raptor.attack === expectedRaptorAttack,
            () => raider.attack === expectedRaiderAttack
        ]);
    }
    
    static testTriggerOrder(): TestResult {
        const test = new GameTest();
        
        test.setupGame([
            { player: 1, cards: ['Redemption', 'Selfless Hero'] },
            { player: 2, cards: ['Fireball'] }
        ]);
        
        // 设置救赎
        test.playCard(1, 'Redemption');
        test.playCard(1, 'Selfless Hero');
        
        // 使用火球术
        test.playCard(2, 'Fireball', test.getEntity(1, 'Selfless Hero'));
        
        // 验证触发顺序
        // 1. 自爆绵羊亡语
        // 2. 救赎触发
        
        return test.assert([
            () => test.getEntity(1, 'Selfless Hero').zone === ZoneType.GRAVEYARD,
            () => test.getEntity(1, 'Selfless Hero').tags.get(TagType.REDEEMED) === 1
        ]);
    }
}
```

---

## 总结

炉石传说的高级机制展现了以下设计特点：

1. **层次化的优先级系统**: 确保复杂的交互有明确的执行顺序
2. **灵活的条件系统**: 支持各种复杂的效果触发条件
3. **可预测的随机性**: 支持回放和验证
4. **高效的更新机制**: 最小化不必要的计算
5. **完善的调试支持**: 便于开发和测试

这些高级机制的实现需要仔细的设计和充分的测试，以确保游戏的稳定性和可玩性。
