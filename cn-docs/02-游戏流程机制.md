# 炉石传说游戏流程机制分析

## 概述

本文档详细分析炉石传说的游戏流程，包括回合结构、玩家操作、事件处理等关键流程。从程序实现的角度解析游戏是如何组织和执行各种操作的。

---

## 1. 回合流程系统

### 1.1 回合状态机

炉石传说的回合系统采用**状态机模式**，每个回合都有明确的状态转换。

```typescript
// 回合状态枚举
enum TurnStep {
    BEGIN_FIRST = 0,      // 游戏开始
    BEGIN_SHUFFLE = 1,    // 洗牌
    BEGIN_DRAW = 2,       // 起始手牌
    BEGIN_MULLIGAN = 3,   // 换牌
    MAIN_READY = 4,       // 准备步骤
    MAIN_START_TRIGGERS = 5, // 回合开始阶段
    MAIN_START = 6,       // 抽牌阶段
    MAIN_ACTION = 7,      // 主时段
    MAIN_END = 8,         // 回合结束阶段
    MAIN_CLEANUP = 9,     // 清除步骤
    MAIN_NEXT = 10        // 回合间步骤
}

// 回合管理器
class TurnManager {
    private currentPlayer: PlayerId = 1;
    private currentStep: TurnStep = TurnStep.BEGIN_FIRST;
    private turnNumber: number = 1;
    private maxTurns: number = 90;
    
    // 当前回合状态
    private state: TurnState = {
        player: 1,
        step: TurnStep.BEGIN_FIRST,
        canAct: false,
        timeRemaining: 75
    };
    
    // 进入下一步骤
    advanceStep(): void {
        switch (this.currentStep) {
            case TurnStep.BEGIN_FIRST:
                this.currentStep = TurnStep.BEGIN_SHUFFLE;
                this.shuffleDecks();
                break;
                
            case TurnStep.BEGIN_SHUFFLE:
                this.currentStep = TurnStep.BEGIN_DRAW;
                this.drawOpeningHands();
                break;
                
            case TurnStep.BEGIN_DRAW:
                this.currentStep = TurnStep.BEGIN_MULLIGAN;
                this.startMulligan();
                break;
                
            case TurnStep.BEGIN_MULLIGAN:
                this.currentStep = TurnStep.MAIN_READY;
                this.processReadyStep();
                break;
                
            case TurnStep.MAIN_READY:
                this.currentStep = TurnStep.MAIN_START_TRIGGERS;
                this.processStartTriggers();
                break;
                
            case TurnStep.MAIN_START_TRIGGERS:
                this.currentStep = TurnStep.MAIN_START;
                this.drawCard();
                break;
                
            case TurnStep.MAIN_START:
                this.currentStep = TurnStep.MAIN_ACTION;
                this.startMainAction();
                break;
                
            case TurnStep.MAIN_ACTION:
                // 等待玩家操作或回合结束
                break;
                
            case TurnStep.MAIN_END:
                this.currentStep = TurnStep.MAIN_CLEANUP;
                this.processCleanup();
                break;
                
            case TurnStep.MAIN_CLEANUP:
                this.currentStep = TurnStep.MAIN_NEXT;
                this.endTurn();
                break;
                
            case TurnStep.MAIN_NEXT:
                this.currentStep = TurnStep.MAIN_READY;
                this.startNextTurn();
                break;
        }
    }
    
    // 准备步骤
    private processReadyStep(): void {
        const player = this.getCurrentPlayer();
        
        // 1. 增加在场回合数
        for (const entity of player.getAllEntities()) {
            const currentTurns = entity.tags.get(TagType.NUM_TURNS_IN_PLAY) || 0;
            entity.tags.set(TagType.NUM_TURNS_IN_PLAY, currentTurns + 1);
        }
        
        // 2. 恢复法力值
        player.mana = Math.min(player.maxMana + 1, 10);
        player.maxMana = Math.min(player.maxMana + 1, 10);
        player.overload = player.pendingOverload;
        player.pendingOverload = 0;
        
        // 3. 重置"本回合"标签
        player.tags.set(TagType.NUM_CARDS_PLAYED_THIS_TURN, 0);
        player.tags.set(TagType.NUM_MINIONS_KILLED_THIS_TURN, 0);
        
        // 4. 重置攻击次数
        for (const entity of player.getCharacters()) {
            entity.tags.set(TagType.NUM_ATTACKS_THIS_TURN, 0);
        }
        
        // 5. 武器状态
        if (player.weapon) {
            player.weapon.tags.set(TagType.EXHAUSTED, 0);
        }
        
        // 6. 奥秘状态
        for (const secret of player.secrets) {
            secret.tags.set(TagType.EXHAUSTED, 0);
        }
        
        this.advanceStep();
    }
    
    // 回合开始阶段
    private processStartTriggers(): void {
        // 创建回合开始序列
        const sequence = new TurnStartSequence(this.currentPlayer);
        sequence.start(() => {
            this.advanceStep();
        });
    }
    
    // 抽牌
    private drawCard(): void {
        const player = this.getCurrentPlayer();
        player.drawCards(1);
        this.advanceStep();
    }
    
    // 开始主时段
    private startMainAction(): void {
        this.state.canAct = true;
        this.startTurnTimer();
        
        // 通知客户端可以行动
        NetworkManager.notifyTurnStart(this.currentPlayer);
    }
    
    // 回合结束
    endTurn(): void {
        if (this.currentStep !== TurnStep.MAIN_ACTION) {
            return;
        }
        
        this.state.canAct = false;
        this.currentStep = TurnStep.MAIN_END;
        this.processEndStep();
    }
    
    // 回合结束阶段
    private processEndStep(): void {
        const sequence = new TurnEndSequence(this.currentPlayer);
        sequence.start(() => {
            this.advanceStep();
        });
    }
    
    // 清除步骤
    private processCleanup(): void {
        const player = this.getCurrentPlayer();
        
        // 1. 清除召唤失调
        for (const minion of player.minions) {
            minion.tags.set(TagType.JUST_PLAYED, 0);
        }
        
        // 2. 移除过期状态
        this.removeExpiredEnchantments(player);
        
        this.advanceStep();
    }
    
    // 回合间步骤
    private endTurn(): void {
        // 1. 增加手牌入手回合数
        const player = this.getCurrentPlayer();
        for (const card of player.hand) {
            const turnsInHand = card.tags.get(TagType.NUM_TURNS_IN_HAND) || 0;
            card.tags.set(TagType.NUM_TURNS_IN_HAND, turnsInHand + 1);
        }
        
        // 2. 切换玩家
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        
        // 3. 增加总回合数
        this.turnNumber++;
        
        // 4. 检查回合上限
        if (this.turnNumber > this.maxTurns) {
            GameManager.endGame(null, VictoryType.TIE);
            return;
        }
        
        this.advanceStep();
    }
    
    // 开始下一回合
    private startNextTurn(): void {
        NetworkManager.notifyTurnEnd(this.currentPlayer === 2 ? 1 : 2);
        this.advanceStep();
    }
}
```

---

## 2. 卡牌使用流程

### 2.1 通用卡牌使用序列

```typescript
// 卡牌使用序列基类
abstract class CardPlaySequence implements ISequence {
    protected player: PlayerId;
    protected card: CardEntity;
    protected target?: IEntity;
    
    phases: IPhase[];
    currentPhase = 0;
    isComplete = false;
    
    constructor(player: PlayerId, card: CardEntity, target?: IEntity) {
        this.player = player;
        this.card = card;
        this.target = target;
        
        this.phases = [
            new PlayPhase(this),
            new CombatPhase(this),
            new CompletePhase(this)
        ];
    }
    
    abstract start(): void;
    abstract nextPhase(): void;
    abstract complete(): void;
}

// 使用阶段
class PlayPhase implements IPhase {
    sequence: CardPlaySequence;
    
    constructor(sequence: CardPlaySequence) {
        this.sequence = sequence;
    }
    
    execute(): IGameEvent[] {
        const events: IGameEvent[] = [];
        const player = this.sequence.player;
        const card = this.sequence.card;
        
        // 1. 支付费用
        player.mana -= card.cost;
        
        // 2. 卡牌进入战场（或奥秘区）
        if (card.type === CardType.SPELL && 
            (card.spellSchool === SpellSchool.SECRET || 
             card.spellSchool === SpellSchool.QUEST)) {
            ZoneManager.moveEntity(card, ZoneType.SECRET);
        } else {
            ZoneManager.moveEntity(card, ZoneType.PLAY);
        }
        
        // 3. 设置相关标签
        card.tags.set(TagType.JUST_PLAYED, 1);
        card.tags.set(TagType.EXHAUSTED, 1);
        
        // 4. 增加本回合使用卡牌数
        const cardsPlayed = player.tags.get(TagType.NUM_CARDS_PLAYED_THIS_TURN) || 0;
        player.tags.set(TagType.NUM_CARDS_PLAYED_THIS_TURN, cardsPlayed + 1);
        
        // 5. 触发"使用时"扳机
        const playEvent: PlayCardEvent = {
            type: EventType.PLAY_CARD,
            source: player,
            targets: [card],
            timestamp: Date.now(),
            data: {
                card: card,
                wasPlayed: true
            }
        };
        events.push(playEvent);
        
        // 6. 触发"召唤时"扳机（随从）
        if (card.type === CardType.MINION) {
            const summonEvent: SummonEvent = {
                type: EventType.SUMMON,
                source: player,
                targets: [card],
                timestamp: Date.now(),
                data: {
                    isPlayed: true
                }
            };
            events.push(summonEvent);
        }
        
        return events;
    }
    
    cleanup(): void {
        // 阶段清理
    }
}

// 结算阶段
class CombatPhase implements IPhase {
    sequence: CardPlaySequence;
    
    constructor(sequence: CardPlaySequence) {
        this.sequence = sequence;
    }
    
    execute(): IGameEvent[] {
        const events: IGameEvent[] = [];
        const card = this.sequence.card;
        
        switch (card.type) {
            case CardType.MINION:
                return this.processMinion(card as MinionEntity);
            case CardType.SPELL:
                return this.processSpell(card as SpellEntity);
            case CardType.WEAPON:
                return this.processWeapon(card as WeaponEntity);
            default:
                return events;
        }
    }
    
    private processMinion(minion: MinionEntity): IGameEvent[] {
        // 处理战吼/连击/抉择
        if (minion.battlecry) {
            return minion.battlecry.execute(this.sequence.target);
        }
        return [];
    }
    
    private processSpell(spell: SpellEntity): IGameEvent[] {
        // 处理法术效果
        return spell.spellEffect.execute(this.sequence.target);
    }
    
    private processWeapon(weapon: WeaponEntity): IGameEvent[] {
        // 处理武器战吼
        if (weapon.battlecry) {
            return weapon.battlecry.execute(this.sequence.target);
        }
        return [];
    }
    
    cleanup(): void {
        // 阶段清理
    }
}

// 完成阶段
class CompletePhase implements IPhase {
    sequence: CardPlaySequence;
    
    constructor(sequence: CardPlaySequence) {
        this.sequence = sequence;
    }
    
    execute(): IGameEvent[] {
        const events: IGameEvent[] = [];
        const player = this.sequence.player;
        const card = this.sequence.card;
        
        // 1. 触发"召唤后"扳机（随从）
        if (card.type === CardType.MINION) {
            const summonEvent: SummonEvent = {
                type: EventType.AFTER_SUMMON,
                source: player,
                targets: [card],
                timestamp: Date.now(),
                data: {
                    isPlayed: true
                }
            };
            events.push(summonEvent);
        }
        
        // 2. 触发"使用后"扳机
        const afterPlayEvent: AfterPlayCardEvent = {
            type: EventType.AFTER_PLAY_CARD,
            source: player,
            targets: [card],
            timestamp: Date.now(),
            data: {
                card: card
            }
        };
        events.push(afterPlayEvent);
        
        // 3. 处理回响
        if (card.keywords.has(KeywordType.ECHO)) {
            this.processEcho(card);
        }
        
        return events;
    }
    
    private processEcho(card: CardEntity): void {
        // 回响机制：在手牌中创建临时副本
        const echoCopy = CardFactory.createCard(card.cardId);
        echoCopy.tags.set(TagType.ECHO, 1);
        echoCopy.tags.set(TagType.TEMPORARY, 1);
        ZoneManager.moveEntity(echoCopy, ZoneType.HAND, this.sequence.player);
    }
    
    cleanup(): void {
        // 阶段清理
    }
}
```

---

## 3. 战斗流程

### 3.1 战斗序列

```typescript
class CombatSequence implements ISequence {
    id: number;
    type = SequenceType.COMBAT;
    player: PlayerId;
    attacker: IEntity;
    defender: IEntity;
    
    phases: IPhase[];
    currentPhase = 0;
    isComplete = false;
    
    private attackTriggers: ITrigger[] = [];
    private hasDefenderChanged = false;
    
    constructor(player: PlayerId, attacker: IEntity, defender: IEntity) {
        this.id = SequenceManager.getNextSequenceId();
        this.player = player;
        this.attacker = attacker;
        this.defender = defender;
        
        this.phases = [
            new PreAttackPhase(this),
            new AttackPhase(this),
            new DamagePhase(this),
            new AfterAttackPhase(this)
        ];
    }
    
    start(): void {
        this.nextPhase();
    }
    
    nextPhase(): void {
        if (this.currentPhase < this.phases.length) {
            const phase = this.phases[this.currentPhase++];
            const events = phase.execute();
            
            for (const event of events) {
                EventManager.triggerEvent(event);
            }
            
            // 检查防御者是否改变
            if (this.hasDefenderChanged && this.currentPhase === 1) {
                // 重新执行攻击前阶段
                this.currentPhase = 0;
                this.hasDefenderChanged = false;
            }
            
            phase.cleanup();
            this.nextPhase();
        } else {
            this.complete();
        }
    }
    
    complete(): void {
        this.isComplete = true;
        
        // 增加攻击次数
        const currentAttacks = this.attacker.tags.get(TagType.NUM_ATTACKS_THIS_TURN) || 0;
        this.attacker.tags.set(TagType.NUM_ATTACKS_THIS_TURN, currentAttacks + 1);
        
        // 胜负裁定
        VictoryManager.checkVictory();
    }
}

// 攻击前阶段
class PreAttackPhase implements IPhase {
    sequence: CombatSequence;
    
    constructor(sequence: CombatSequence) {
        this.sequence = sequence;
    }
    
    execute(): IGameEvent[] {
        const events: IGameEvent[] = [];
        
        // 1. 收集攻击前扳机
        const triggers = this.getPreAttackTriggers();
        
        // 2. 按顺序触发扳机
        for (const trigger of triggers) {
            if (trigger.condition(this.sequence)) {
                const newEvents = trigger.onTrigger(this.sequence);
                if (newEvents) {
                    events.push(...newEvents);
                }
            }
        }
        
        return events;
    }
    
    private getPreAttackTriggers(): ITrigger[] {
        const triggers: ITrigger[] = [];
        const game = GameManager.getGame();
        
        // 收集奥秘扳机
        for (const player of game.players) {
            for (const secret of player.secrets) {
                if (secret.secretType === SecretType.ATTACK_PREVENTION) {
                    triggers.push(new SecretTrigger(secret));
                }
            }
        }
        
        // 排序：入场顺序
        triggers.sort((a, b) => a.entity.id - b.entity.id);
        
        return triggers;
    }
    
    cleanup(): void {
        // 阶段清理
    }
}

// 伤害阶段
class DamagePhase implements IPhase {
    sequence: CombatSequence;
    
    constructor(sequence: CombatSequence) {
        this.sequence = sequence;
    }
    
    execute(): IGameEvent[] {
        const events: IGameEvent[] = [];
        const attacker = this.sequence.attacker;
        const defender = this.sequence.defender;
        
        // 1. 计算伤害
        const attackerDamage = this.calculateDamage(attacker, defender);
        const defenderDamage = this.calculateDamage(defender, attacker);
        
        // 2. 创建伤害事件
        const attackerDamageEvent: DamageEvent = {
            type: EventType.DAMAGE,
            source: attacker,
            targets: [defender],
            timestamp: Date.now(),
            data: {
                amount: attackerDamage,
                isSpellDamage: false,
                isCombatDamage: true
            }
        };
        
        const defenderDamageEvent: DamageEvent = {
            type: EventType.DAMAGE,
            source: defender,
            targets: [attacker],
            timestamp: Date.now(),
            data: {
                amount: defenderDamage,
                isSpellDamage: false,
                isCombatDamage: true
            }
        };
        
        events.push(attackerDamageEvent, defenderDamageEvent);
        
        // 3. 处理伤害
        this.applyDamage(defender, attackerDamage);
        this.applyDamage(attacker, defenderDamage);
        
        // 4. 移除潜行
        if (attacker.tags.get(TagType.STEALTH)) {
            attacker.tags.set(TagType.STEALTH, 0);
        }
        
        // 5. 减少武器耐久
        if (attacker.type === EntityType.HERO && attacker.weapon) {
            attacker.weapon.durability--;
        }
        
        return events;
    }
    
    private calculateDamage(source: IEntity, target: IEntity): number {
        let damage = source.attack || 0;
        
        // 应用各种加成
        damage = this.applyDamageModifiers(damage, source, target);
        
        return damage;
    }
    
    private applyDamage(amount: number, entity: IEntity): void {
        if (entity.type === EntityType.HERO) {
            // 英雄受到伤害
            const hero = entity as HeroEntity;
            
            // 先扣除护甲
            if (hero.armor > 0) {
                const armorDamage = Math.min(amount, hero.armor);
                hero.armor -= armorDamage;
                amount -= armorDamage;
            }
            
            // 再扣除生命值
            if (amount > 0) {
                hero.health = Math.max(0, hero.health - amount);
            }
        } else if (entity.type === EntityType.MINION) {
            // 随从受到伤害
            const minion = entity as MinionEntity;
            minion.health = Math.max(0, minion.health - amount);
        }
    }
    
    cleanup(): void {
        // 阶段清理
    }
}
```

---

## 4. 事件处理流程

### 4.1 事件队列系统

```typescript
class EventProcessor {
    private mainQueue: IGameEvent[] = [];
    private nestedQueue: IGameEvent[] = [];
    private processingDepth = 0;
    private maxDepth = 100; // 防止无限递归
    
    // 添加事件到队列
    enqueue(event: IGameEvent): void {
        if (this.processingDepth === 0) {
            this.mainQueue.push(event);
        } else {
            // 嵌套事件插入到队列前端（深度优先）
            this.nestedQueue.unshift(event);
        }
    }
    
    // 处理事件队列
    process(): void {
        if (this.processingDepth > this.maxDepth) {
            console.error('Event processing depth exceeded maximum');
            return;
        }
        
        this.processingDepth++;
        
        try {
            // 处理嵌套队列
            while (this.nestedQueue.length > 0) {
                const event = this.nestedQueue.shift()!;
                this.processEvent(event);
            }
            
            // 处理主队列
            while (this.mainQueue.length > 0) {
                const event = this.mainQueue.shift()!;
                this.processEvent(event);
            }
        } finally {
            this.processingDepth--;
        }
    }
    
    // 处理单个事件
    private processEvent(event: IGameEvent): void {
        // 1. 收集扳机
        const triggers = this.collectTriggers(event);
        
        // 2. 排序扳机
        const sortedTriggers = this.sortTriggers(triggers, event);
        
        // 3. 执行扳机
        for (const trigger of sortedTriggers) {
            try {
                const newEvents = trigger.onTrigger(event);
                if (newEvents && newEvents.length > 0) {
                    this.nestedQueue.unshift(...newEvents);
                }
            } catch (error) {
                console.error('Error executing trigger:', error);
                // 错误处理：记录但不中断流程
            }
        }
    }
    
    // 收集扳机
    private collectTriggers(event: IGameEvent): ITrigger[] {
        const triggers: ITrigger[] = [];
        const game = GameManager.getGame();
        
        // 1. 游戏扳机
        const gameTriggers = game.getTriggers(event.type);
        triggers.push(...gameTriggers);
        
        // 2. 玩家扳机
        for (const player of game.players) {
            const playerTriggers = player.getTriggers(event.type);
            triggers.push(...playerTriggers);
        }
        
        // 3. 实体扳机
        for (const entity of game.getAllEntities()) {
            if (entity.zone === ZoneType.PLAY) {
                const entityTriggers = entity.getTriggers(event.type);
                triggers.push(...entityTriggers);
            }
        }
        
        return triggers;
    }
    
    // 排序扳机
    private sortTriggers(triggers: ITrigger[], event: IGameEvent): ITrigger[] {
        return triggers.sort((a, b) => {
            // 1. 按优先级排序
            if (a.priority !== b.priority) {
                return a.priority - b.priority;
            }
            
            // 2. 按区域排序：场上 > 手牌 > 牌库
            const zoneOrder = this.getZoneOrder(a.entity.zone);
            const bZoneOrder = this.getZoneOrder(b.entity.zone);
            if (zoneOrder !== bZoneOrder) {
                return zoneOrder - bZoneOrder;
            }
            
            // 3. 按入场顺序
            return a.entity.id - b.entity.id;
        });
    }
    
    private getZoneOrder(zone: ZoneType): number {
        switch (zone) {
            case ZoneType.PLAY: return 1;
            case ZoneType.HAND: return 2;
            case ZoneType.DECK: return 3;
            default: return 4;
        }
    }
}
```

---

## 5. 关键流程总结

### 5.1 完整回合流程

```
游戏开始
    ↓
洗牌
    ↓
起始手牌
    ↓
换牌阶段
    ↓
回合1开始
    ↓
准备步骤 (重置状态、恢复法力)
    ↓
回合开始阶段 (触发回合开始扳机)
    ↓
抽牌阶段
    ↓
主时段 (玩家操作)
    ↓
回合结束阶段 (触发回合结束扳机)
    ↓
清除步骤 (移除过期效果)
    ↓
回合间步骤 (切换玩家)
    ↓
回合2开始
    ↓
... (循环)
```

### 5.2 卡牌使用流程

```
玩家选择卡牌
    ↓
支付费用
    ↓
卡牌进入战场/奥秘区
    ↓
触发"使用时"扳机
    ↓
触发"召唤时"扳机（随从）
    ↓
结算战吼/法术效果
    ↓
触发"召唤后"扳机（随从）
    ↓
触发"使用后"扳机
    ↓
死亡检索
    ↓
胜负裁定
```

### 5.3 战斗流程

```
选择攻击者和防御者
    ↓
攻击前阶段 (奥秘、陷阱等)
    ↓
防御者改变？→ 重新执行攻击前阶段
    ↓
攻击时阶段 (攻击时扳机)
    ↓
造成伤害 (双方同时)
    ↓
结算伤害事件
    ↓
攻击后阶段 (攻击后扳机)
    ↓
死亡检索
    ↓
胜负裁定
```

---

## 6. 性能优化要点

### 6.1 事件处理优化

1. **事件批处理**
   ```typescript
   // 批量处理同类型事件
   batchProcessEvents(events: IGameEvent[]): void {
       const batchedEvents = this.groupEventsByType(events);
       for (const [type, eventGroup] of batchedEvents) {
           this.processEventBatch(type, eventGroup);
       }
   }
   ```

2. **扳机缓存**
   ```typescript
   // 缓存扳机排序结果
   private triggerCache = new Map<string, ITrigger[]>();
   
   getCachedTriggers(eventType: EventType): ITrigger[] {
       const cacheKey = `${eventType}`;
       if (!this.triggerCache.has(cacheKey)) {
           const triggers = this.collectTriggers(eventType);
           this.triggerCache.set(cacheKey, triggers);
       }
       return this.triggerCache.get(cacheKey)!;
   }
   ```

3. **事件对象池**
   ```typescript
   // 复用事件对象
   class EventPool {
       private pool: IGameEvent[] = [];
       
       acquire(): IGameEvent {
           return this.pool.pop() || {} as IGameEvent;
       }
       
       release(event: IGameEvent): void {
           // 清理事件数据
           Object.keys(event).forEach(key => delete (event as any)[key]);
           this.pool.push(event);
       }
   }
   ```

### 6.2 序列优化

1. **序列复用**
   ```typescript
   // 复用序列对象
   class SequencePool {
       private pools = new Map<SequenceType, ISequence[]>();
       
       acquire(type: SequenceType): ISequence {
           const pool = this.pools.get(type) || [];
           return pool.pop() || this.createSequence(type);
       }
       
       release(sequence: ISequence): void {
           sequence.reset();
           const pool = this.pools.get(sequence.type) || [];
           pool.push(sequence);
           this.pools.set(sequence.type, pool);
       }
   }
   ```

2. **延迟执行**
   ```typescript
   // 非关键逻辑延迟执行
   deferExecution(fn: () => void): void {
       setTimeout(fn, 0);
   }
   ```

---

## 7. 调试与监控

### 7.1 流程监控

```typescript
class GameFlowMonitor {
    private flowStack: FlowFrame[] = [];
    
    startFlow(flowName: string, data?: any): void {
        const frame: FlowFrame = {
            name: flowName,
            startTime: Date.now(),
            data: data,
            depth: this.flowStack.length
        };
        
        this.flowStack.push(frame);
        
        if (Config.debugMode) {
            console.log(`[${frame.depth}] Start: ${flowName}`, data);
        }
    }
    
    endFlow(flowName: string): void {
        const frame = this.flowStack.pop();
        if (!frame || frame.name !== flowName) {
            console.error(`Flow mismatch: expected ${flowName}, got ${frame?.name}`);
            return;
        }
        
        const duration = Date.now() - frame.startTime;
        
        if (Config.debugMode) {
            console.log(`[${frame.depth}] End: ${flowName} (${duration}ms)`);
        }
        
        // 性能警告
        if (duration > 100) {
            console.warn(`Slow flow detected: ${flowName} took ${duration}ms`);
        }
    }
}
```

### 7.2 状态快照

```typescript
class GameStateSnapshot {
    static capture(): GameSnapshot {
        const game = GameManager.getGame();
        
        return {
            timestamp: Date.now(),
            turn: game.turn,
            step: game.step,
            players: game.players.map(player => ({
                id: player.id,
                health: player.hero.health,
                armor: player.hero.armor,
                mana: player.mana,
                handSize: player.hand.length,
                boardSize: player.minions.length
            })),
            entities: game.getAllEntities().map(entity => ({
                id: entity.id,
                type: entity.type,
                zone: entity.zone,
                controller: entity.controller,
                tags: Object.fromEntries(entity.tags)
            }))
        };
    }
    
    static restore(snapshot: GameSnapshot): void {
        // 恢复游戏状态
        // 用于调试和回放
    }
}
```

---

## 总结

炉石传说的游戏流程机制体现了以下设计原则：

1. **状态驱动**: 使用状态机管理回合流程
2. **事件驱动**: 通过事件系统连接各个模块
3. **分阶段处理**: 复杂操作分解为多个阶段
4. **优先级管理**: 严格的执行顺序保证
5. **错误容忍**: 异常情况下的健壮处理

理解这些流程机制是实现稳定、可扩展的游戏系统的基础。
