# 炉石传说核心系统机制分析

## 概述

本文档从系统设计的角度深入分析炉石传说的核心机制，旨在为开发者提供清晰的技术实现思路。

---

## 1. 实体系统（Entity System）

### 1.1 架构设计

炉石传说采用基于**实体组件系统（ECS）**的架构，但又有所创新。

#### 核心实体类型

```typescript
// 基础实体接口
interface IEntity {
    id: number;              // 唯一标识符
    type: EntityType;        // 实体类型
    zone: ZoneType;          // 所在区域
    zonePosition: number;    // 区域位置
    controller: PlayerId;    // 控制者
    tags: Map<TagType, any>; // 标签集合
}

// 具体实体类型
interface GameEntity extends IEntity {
    type: EntityType.GAME;
    turn: number;
    step: GameStep;
}

interface PlayerEntity extends IEntity {
    type: EntityType.PLAYER;
    hero: HeroEntity;
    heroPower: HeroPowerEntity;
    hand: CardEntity[];
    deck: CardEntity[];
    handSize: number;
}

interface HeroEntity extends IEntity {
    type: EntityType.HERO;
    health: number;
    maxHealth: number;
    armor: number;
    attack: number;
    isExhausted: boolean;
}

interface MinionEntity extends IEntity {
    type: EntityType.MINION;
    attack: number;
    health: number;
    maxHealth: number;
    cost: number;
    isExhausted: boolean;
    isTaunt: boolean;
    isStealth: boolean;
    isDivineShield: boolean;
}

interface SpellEntity extends IEntity {
    type: EntityType.SPELL;
    cost: number;
    spellSchool: SpellSchool;
}

interface WeaponEntity extends IEntity {
    type: EntityType.WEAPON;
    attack: number;
    durability: number;
    maxDurability: number;
}

interface EnchantmentEntity extends IEntity {
    type: EntityType.ENCHANTMENT;
    target: IEntity;
    source: IEntity;
    isVisible: boolean;
}
```

### 1.2 ID分配机制

```typescript
class EntityManager {
    private nextId: number = 1;
    private entities: Map<number, IEntity> = new Map();
    
    createEntity(type: EntityType): IEntity {
        const entity: IEntity = {
            id: this.nextId++,
            type,
            zone: ZoneType.SETASIDE, // 初始在除外区
            zonePosition: 0,
            controller: 0,
            tags: new Map()
        };
        this.entities.set(entity.id, entity);
        return entity;
    }
    
    // 初始化游戏时的ID分配顺序
    initializeGame() {
        this.createEntity(EntityType.GAME);     // ID: 1
        this.createEntity(EntityType.PLAYER);   // ID: 2 (主玩家)
        this.createEntity(EntityType.PLAYER);   // ID: 3 (副玩家)
        
        // 主玩家套牌 (ID: 4-33)
        for (let i = 0; i < 30; i++) {
            this.createEntity(EntityType.CARD);
        }
        
        // 副玩家套牌 (ID: 34-63)
        for (let i = 0; i < 30; i++) {
            this.createEntity(EntityType.CARD);
        }
        
        this.createEntity(EntityType.HERO);     // ID: 64 (主英雄)
        this.createEntity(EntityType.HERO_POWER); // ID: 65 (主英雄技能)
        this.createEntity(EntityType.HERO);     // ID: 66 (副英雄)
        this.createEntity(EntityType.HERO_POWER); // ID: 67 (副英雄技能)
        this.createEntity(EntityType.SPELL);    // ID: 68 (幸运币)
    }
}
```

---

## 2. 区域系统（Zone System）

### 2.1 区域架构

区域系统是炉石传说的核心，决定了实体的位置和功能。

```typescript
enum ZoneType {
    PLAY = "PLAY",           // 战场
    SECRET = "SECRET",       // 奥秘区
    HAND = "HAND",          // 手牌
    DECK = "DECK",          // 牌库
    GRAVEYARD = "GRAVEYARD", // 墓地
    SETASIDE = "SETASIDE",   // 除外区
    REMOVEDFROMGAME = "REMOVEDFROMGAME", // 失效区
    LETTUCE_ABILITY = "LETTUCE_ABILITY"  // 佣兵技能区
}

class ZoneManager {
    private zones: Map<ZoneType, Map<PlayerId, IEntity[]>> = new Map();
    
    constructor() {
        // 为每个玩家初始化各个区域
        for (const zoneType of Object.values(ZoneType)) {
            this.zones.set(zoneType, new Map());
            this.zones.get(zoneType)!.set(1, []); // 主玩家
            this.zones.get(zoneType)!.set(2, []); // 副玩家
        }
    }
    
    moveEntity(entity: IEntity, newZone: ZoneType, newPosition?: number): boolean {
        const oldZone = entity.zone;
        const oldController = entity.controller;
        
        // 检查目标区域是否已满
        if (!this.canMoveToZone(entity, newZone)) {
            return false;
        }
        
        // 从旧区域移除
        this.removeFromZone(entity, oldZone, oldController);
        
        // 添加到新区域
        entity.zone = newZone;
        if (newPosition !== undefined) {
            entity.zonePosition = newPosition;
        }
        
        this.addToZone(entity, newZone, entity.controller);
        
        // 触发区域移动事件
        this.onZoneChanged(entity, oldZone, newZone);
        
        return true;
    }
    
    private canMoveToZone(entity: IEntity, zone: ZoneType): boolean {
        switch (zone) {
            case ZoneType.PLAY:
                return this.getZoneCount(zone, entity.controller) < 7; // 随从上限
            case ZoneType.HAND:
                return this.getZoneCount(zone, entity.controller) < 10; // 手牌上限
            default:
                return true;
        }
    }
    
    private getZoneCount(zone: ZoneType, player: PlayerId): number {
        return this.zones.get(zone)!.get(player)!.length;
    }
}
```

### 2.2 区域移动规则

```typescript
class ZoneMovementRules {
    // 移动到已满的区域时的处理
    static handleFullZone(entity: IEntity, targetZone: ZoneType): MoveResult {
        switch (targetZone) {
            case ZoneType.PLAY:
                // 从牌库到战场（满场）→ 取消移动
                if (entity.zone === ZoneType.DECK) {
                    return MoveResult.CANCELLED;
                }
                // 从手牌到战场（满场）→ 移动到墓地
                if (entity.zone === ZoneType.HAND) {
                    return MoveResult.MOVED_TO_GRAVEYARD;
                }
                break;
                
            case ZoneType.HAND:
                // 从牌库/战场到手牌（满手）→ 烧毁
                return MoveResult.BURNED;
                
            default:
                return MoveResult.CANCELLED;
        }
        return MoveResult.CANCELLED;
    }
}

enum MoveResult {
    SUCCESS,
    CANCELLED,
    MOVED_TO_GRAVEYARD,
    BURNED
}
```

---

## 3. 事件系统（Event System）

### 3.1 事件架构

```typescript
// 事件基类
interface IGameEvent {
    type: EventType;
    source: IEntity;
    targets: IEntity[];
    timestamp: number;
    data?: any;
}

// 具体事件类型
interface DamageEvent extends IGameEvent {
    type: EventType.DAMAGE;
    data: {
        amount: number;
        isSpellDamage: boolean;
        isCombatDamage: boolean;
    };
}

interface HealEvent extends IGameEvent {
    type: EventType.HEAL;
    data: {
        amount: number;
    };
}

interface SummonEvent extends IGameEvent {
    type: EventType.SUMMON;
    data: {
        isPlayed: boolean; // 是否是从手牌使用
    };
}

interface DeathEvent extends IGameEvent {
    type: EventType.DEATH;
    data: {
        wasDestroyed: boolean;
        wasSacrificed: boolean;
    };
}

// 事件管理器
class EventManager {
    private eventQueue: IGameEvent[] = [];
    private processingQueue: IGameEvent[] = [];
    
    // 触发事件
    triggerEvent(event: IGameEvent): void {
        this.eventQueue.push(event);
        this.processEvents();
    }
    
    // 处理事件队列（深度优先）
    private processEvents(): void {
        while (this.eventQueue.length > 0) {
            const event = this.eventQueue.shift()!;
            this.processingQueue.push(event);
            
            // 找到响应该事件的所有扳机
            const triggers = this.findTriggersForEvent(event);
            
            // 按顺序触发扳机
            for (const trigger of triggers) {
                const newEvents = trigger.onTrigger(event);
                if (newEvents && newEvents.length > 0) {
                    // 新事件插入队列前端（深度优先）
                    this.eventQueue.unshift(...newEvents);
                }
            }
            
            this.processingQueue.pop();
        }
    }
    
    // 查找事件的扳机
    private findTriggersForEvent(event: IGameEvent): ITrigger[] {
        const triggers: ITrigger[] = [];
        
        // 1. 场上扳机
        const playTriggers = this.getZoneTriggers(ZoneType.PLAY, event.type);
        triggers.push(...playTriggers);
        
        // 2. 手牌扳机
        const handTriggers = this.getZoneTriggers(ZoneType.HAND, event.type);
        triggers.push(...handTriggers);
        
        // 3. 牌库扳机
        const deckTriggers = this.getZoneTriggers(ZoneType.DECK, event.type);
        triggers.push(...deckTriggers);
        
        // 4. 奥秘区扳机
        const secretTriggers = this.getZoneTriggers(ZoneType.SECRET, event.type);
        triggers.push(...secretTriggers);
        
        // 按顺序排序
        return this.sortTriggers(triggers, event);
    }
}
```

### 3.2 扳机系统

```typescript
// 扳机接口
interface ITrigger {
    entity: IEntity;
    eventType: EventType;
    condition?: (event: IGameEvent) => boolean;
    priority: TriggerPriority;
    
    onTrigger(event: IGameEvent): IGameEvent[] | void;
}

// 扳机优先级
enum TriggerPriority {
    HIGH = 1,        // 高优先级（如回响消失）
    NORMAL = 2,      // 普通优先级
    LOW = 3,         // 低优先级（如救赎、吸血）
    LOWEST = 4       // 最低优先级（如复生）
}

// 具体扳机实现
class DamageTrigger implements ITrigger {
    entity: IEntity;
    eventType = EventType.DAMAGE;
    priority = TriggerPriority.NORMAL;
    
    constructor(entity: IEntity) {
        this.entity = entity;
    }
    
    condition(event: DamageEvent): boolean {
        // 检查触发条件
        // 例如：攻击者是否是这个实体
        return event.source.id === this.entity.id;
    }
    
    onTrigger(event: DamageEvent): IGameEvent[] {
        // 触发效果
        // 例如：吸血效果
        if (this.entity.tags.get(TagType.LIFESTEAL)) {
            const healEvent: HealEvent = {
                type: EventType.HEAL,
                source: this.entity,
                targets: [this.entity.controller.hero],
                timestamp: Date.now(),
                data: {
                    amount: event.data.amount
                }
            };
            return [healEvent];
        }
        return [];
    }
}
```

---

## 4. 序列系统（Sequence System）

### 4.1 序列架构

```typescript
// 序列接口
interface ISequence {
    id: number;
    type: SequenceType;
    player: PlayerId;
    phases: IPhase[];
    currentPhase: number;
    isComplete: boolean;
    
    start(): void;
    nextPhase(): void;
    complete(): void;
}

// 阶段接口
interface IPhase {
    id: number;
    type: PhaseType;
    sequence: ISequence;
    
    execute(): IGameEvent[];
    cleanup(): void;
}

// 序列类型
enum SequenceType {
    PLAY_CARD = "PLAY_CARD",
    COMBAT = "COMBAT",
    USE_HERO_POWER = "USE_HERO_POWER",
    TURN_START = "TURN_START",
    TURN_END = "TURN_END"
}

// 阶段类型
enum PhaseType {
    PLAY = "PLAY",
    COMBAT = "COMBAT",
    DEATH = "DEATH",
    COMPLETE = "COMPLETE"
}

// 使用卡牌序列
class PlayCardSequence implements ISequence {
    id: number;
    type = SequenceType.PLAY_CARD;
    player: PlayerId;
    card: CardEntity;
    target?: IEntity;
    
    phases: IPhase[];
    currentPhase = 0;
    isComplete = false;
    
    constructor(player: PlayerId, card: CardEntity, target?: IEntity) {
        this.id = SequenceManager.getNextSequenceId();
        this.player = player;
        this.card = card;
        this.target = target;
        
        this.phases = [
            new PlayPhase(this),      // 使用阶段
            new CombatPhase(this),    // 结算阶段
            new CompletePhase(this)   // 完成阶段
        ];
    }
    
    start(): void {
        this.nextPhase();
    }
    
    nextPhase(): void {
        if (this.currentPhase < this.phases.length) {
            const phase = this.phases[this.currentPhase++];
            const events = phase.execute();
            
            // 触发事件
            for (const event of events) {
                EventManager.triggerEvent(event);
            }
            
            // 死亡检索
            if (this.shouldCheckDeath()) {
                this.checkDeath();
            }
            
            phase.cleanup();
            
            // 继续下一阶段
            this.nextPhase();
        } else {
            this.complete();
        }
    }
    
    private shouldCheckDeath(): boolean {
        // 判断是否需要检查死亡
        return this.currentPhase <= this.phases.length;
    }
    
    private checkDeath(): void {
        // 执行死亡检索步骤
        DeathManager.checkDeath();
    }
    
    complete(): void {
        this.isComplete = true;
        // 胜负裁定
        VictoryManager.checkVictory();
    }
}
```

---

## 5. 死亡系统（Death System）

### 5.1 死亡检索机制

```typescript
class DeathManager {
    private static mortallyWoundedEntities: IEntity[] = [];
    
    // 死亡检索步骤
    static checkDeath(): void {
        // 1. 标记所有濒死实体
        this.markMortallyWoundedEntities();
        
        // 2. 触发死亡时扳机
        this.triggerDeathrattles();
        
        // 3. 移除濒死实体
        this.removeEntities();
        
        // 4. 如果有实体死亡，进入死亡阶段
        if (this.mortallyWoundedEntities.length > 0) {
            this.processDeathPhase();
        }
    }
    
    // 标记濒死实体
    private static markMortallyWoundedEntities(): void {
        const game = GameManager.getGame();
        
        // 检查所有角色
        for (const player of game.players) {
            // 检查英雄
            if (player.hero.health <= 0) {
                this.markAsMortallyWounded(player.hero);
            }
            
            // 检查随从
            for (const minion of player.minions) {
                if (minion.health <= 0) {
                    this.markAsMortallyWounded(minion);
                }
            }
            
            // 检查武器
            if (player.weapon && player.weapon.durability <= 0) {
                this.markAsMortallyWounded(player.weapon);
            }
        }
    }
    
    private static markAsMortallyWounded(entity: IEntity): void {
        entity.tags.set(TagType.TO_BE_DESTROYED, 1);
        this.mortallyWoundedEntities.push(entity);
    }
    
    // 触发死亡时扳机
    private static triggerDeathrattles(): void {
        for (const entity of this.mortallyWoundedEntities) {
            // 触发死亡扳机
            const deathEvent: DeathEvent = {
                type: EventType.DEATH,
                source: entity,
                targets: [entity],
                timestamp: Date.now(),
                data: {
                    wasDestroyed: true,
                    wasSacrificed: false
                }
            };
            
            EventManager.triggerEvent(deathEvent);
        }
    }
    
    // 移除实体
    private static removeEntities(): void {
        // 按入场顺序移除
        this.mortallyWoundedEntities.sort((a, b) => a.id - b.id);
        
        for (const entity of this.mortallyWoundedEntities) {
            ZoneManager.moveEntity(entity, ZoneType.GRAVEYARD);
            
            // 如果是英雄死亡，设置玩家状态
            if (entity.type === EntityType.HERO) {
                const player = (entity as HeroEntity).owner;
                player.tags.set(TagType.PLAYSTATE, PlayState.LOSING);
            }
        }
    }
    
    // 处理死亡阶段
    private static processDeathPhase(): void {
        // 死亡阶段是一个新的序列
        const deathSequence = new DeathSequence(this.mortallyWoundedEntities);
        deathSequence.start();
        
        // 清空濒死实体列表
        this.mortallyWoundedEntities = [];
    }
}
```

---

## 6. 光环系统（Aura System）

### 6.1 光环更新机制

```typescript
class AuraManager {
    private static auras: Map<number, IAura> = new Map();
    
    // 光环更新时机
    static updateAuras(trigger: AuraUpdateTrigger): void {
        const affectedEntities = this.getAffectedEntities(trigger);
        
        for (const entity of affectedEntities) {
            this.applyAurasToEntity(entity);
        }
    }
    
    // 应用光环到实体
    private static applyAurasToEntity(entity: IEntity): void {
        // 1. 移除过期的光环效果
        this.removeExpiredAuras(entity);
        
        // 2. 应用有效的光环
        const applicableAuras = this.getApplicableAuras(entity);
        
        for (const aura of applicableAuras) {
            if (this.shouldApplyAura(entity, aura)) {
                this.applyAuraEffect(entity, aura);
            }
        }
    }
    
    // 获取适用于实体的光环
    private static getApplicableAuras(entity: IEntity): IAura[] {
        const auras: IAura[] = [];
        
        // 检查场上所有光环源
        const game = GameManager.getGame();
        for (const player of game.players) {
            for (const minion of player.minions) {
                if (minion.aura) {
                    if (this.isAuraApplicableToEntity(minion.aura, entity)) {
                        auras.push(minion.aura);
                    }
                }
            }
        }
        
        return auras.sort((a, b) => a.priority - b.priority);
    }
    
    // 检查光环是否适用于实体
    private static isAuraApplicableToEntity(aura: IAura, entity: IEntity): boolean {
        // 检查控制器
        if (aura.affectsOnlyController && entity.controller !== aura.source.controller) {
            return false;
        }
        
        // 检查种族
        if (aura.requiredRace && entity.race !== aura.requiredRace) {
            return false;
        }
        
        // 检查区域
        if (aura.requiredZone && entity.zone !== aura.requiredZone) {
            return false;
        }
        
        return true;
    }
}

// 光环更新触发器
enum AuraUpdateTrigger {
    PHASE_END = "PHASE_END",
    ENTITY_CREATED = "ENTITY_CREATED",
    ENTITY_ENTERED = "ENTITY_ENTERED",
    ENTITY_TRANSFORMED = "ENTITY_TRANSFORMED",
    ENTITY_AWAKENED = "ENTITY_AWAKENED"
}
```

---

## 7. 关键技术要点

### 7.1 性能优化

1. **事件系统优化**
   - 使用对象池减少GC
   - 事件批处理减少调用次数
   - 缓存扳机排序结果

2. **光环系统优化**
   - 增量更新而非全量更新
   - 脏标记机制
   - 预计算光环影响范围

3. **序列系统优化**
   - 序列复用
   - 延迟执行
   - 异步处理非关键逻辑

### 7.2 可扩展性设计

1. **模块化设计**
   - 各个系统独立
   - 清晰的接口定义
   - 插件式扩展

2. **配置驱动**
   - 卡牌数据配置化
   - 规则可配置
   - 效果脚本化

3. **热更新支持**
   - 逻辑与数据分离
   - 运行时重载
   - A/B测试支持

### 7.3 调试与监控

1. **日志系统**
   - 详细的事件日志
   - 性能监控
   - 异常捕获

2. **调试工具**
   - 游戏状态快照
   - 事件流追踪
   - 可视化调试界面

3. **测试框架**
   - 单元测试
   - 集成测试
   - 回归测试

---

## 8. 实现建议

### 8.1 技术选型

- **语言**: TypeScript（类型安全，适合复杂逻辑）
- **架构**: 事件驱动架构
- **数据存储**: 内存数据库（快速访问）
- **网络**: WebSocket（实时通信）
- **测试**: Jest（单元测试框架）

### 8.2 开发顺序

1. **第一阶段**: 基础实体系统
   - 实体管理
   - 区域管理
   - 基础移动

2. **第二阶段**: 事件系统
   - 事件管理
   - 扳机系统
   - 基础效果

3. **第三阶段**: 游戏流程
   - 回合系统
   - 序列系统
   - 胜负判定

4. **第四阶段**: 高级机制
   - 光环系统
   - 复杂效果
   - 特殊规则

5. **第五阶段**: 优化与扩展
   - 性能优化
   - 调试工具
   - 测试覆盖

---

## 总结

炉石传说的核心系统机制体现了以下设计原则：

1. **清晰的数据模型**: 实体-标签系统
2. **明确的生命周期**: 区域移动规则
3. **灵活的事件响应**: 扳机系统
4. **严格的执行顺序**: 序列与阶段
5. **高效的状态管理**: 光环更新机制

理解这些核心机制是成功实现游戏的关键。
