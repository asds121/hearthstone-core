# 炉石传说游戏系统接口文档

**文档版本**: 1.0  
**编写日期**: 2025-12-17  
**编写人**: AI助手  
**审核状态**: 待审核

---

## 1. 概述

### 1.1 文档目的

本文档详细描述炉石传说游戏系统的所有接口，包括外部API接口、内部模块接口、数据接口等，为系统开发和集成提供参考。

### 1.2 接口分类

本文档包含以下接口类型：
- **外部API接口**: 对外提供的RESTful API
- **WebSocket接口**: 实时通信接口
- **内部模块接口**: 模块间通信接口
- **数据访问接口**: 数据层接口

### 1.3 接口规范

- **传输协议**: HTTP/HTTPS, WebSocket
- **数据格式**: JSON
- **编码**: UTF-8
- **认证**: JWT Token

### 1.4 版本信息

- **当前版本**: v1.0
- **版本控制**: 语义化版本控制
- **兼容性**: 向后兼容

---

## 2. 外部API接口

### 2.1 游戏控制接口

#### 2.1.1 开始游戏

**接口名称**: 开始游戏  
**接口地址**: `POST /api/v1/games`  
**请求方式**: POST  
**接口描述**: 创建并开始一局新游戏

**请求参数**:

```json
{
  "player1": {
    "id": "player_123",
    "name": "Player1",
    "deck": [
      {
        "id": "card_001",
        "name": "Bloodfen Raptor",
        "cost": 2,
        "attack": 3,
        "health": 2,
        "type": "minion"
      }
    ]
  },
  "player2": {
    "id": "player_456",
    "name": "Player2",
    "deck": [
      {
        "id": "card_002",
        "name": "Murloc Raider",
        "cost": 1,
        "attack": 2,
        "health": 1,
        "type": "minion"
      }
    ]
  },
  "config": {
    "maxTurns": 90,
    "turnTimeLimit": 75,
    "mulliganTimeLimit": 60
  }
}
```

**响应参数**:

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "gameId": "game_789",
    "status": "started",
    "currentPlayer": "player_123",
    "turn": 1,
    "step": "mulligan",
    "players": [
      {
        "id": "player_123",
        "name": "Player1",
        "health": 30,
        "mana": 0,
        "maxMana": 0,
        "handSize": 4,
        "deckSize": 30
      },
      {
        "id": "player_456",
        "name": "Player2",
        "health": 30,
        "mana": 0,
        "maxMana": 0,
        "handSize": 4,
        "deckSize": 30
      }
    ]
  }
}
```

**错误响应**:

```json
{
  "code": 400,
  "message": "Invalid deck configuration",
  "errors": [
    {
      "field": "player1.deck",
      "message": "Deck must contain exactly 30 cards"
    }
  ]
}
```

#### 2.1.2 结束回合

**接口名称**: 结束回合  
**接口地址**: `POST /api/v1/games/{gameId}/turn/end`  
**请求方式**: POST  
**接口描述**: 结束当前玩家的回合

**请求参数**:

```json
{
  "playerId": "player_123"
}
```

**响应参数**:

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "gameId": "game_789",
    "currentPlayer": "player_456",
    "turn": 2,
    "step": "ready",
    "events": [
      {
        "type": "turn_end",
        "playerId": "player_123",
        "timestamp": 1640995200000
      },
      {
        "type": "turn_start",
        "playerId": "player_456",
        "timestamp": 1640995201000
      }
    ]
  }
}
```

#### 2.1.3 使用卡牌

**接口名称**: 使用卡牌  
**接口地址**: `POST /api/v1/games/{gameId}/cards/{cardId}/play`  
**请求方式**: POST  
**接口描述**: 使用一张手牌

**请求参数**:

```json
{
  "playerId": "player_123",
  "targetId": "entity_456",  // 可选
  "position": 3  // 可选，随从入场位置
}
```

**响应参数**:

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "gameId": "game_789",
    "cardId": "card_001",
    "cardName": "Bloodfen Raptor",
    "result": {
      "type": "summon",
      "entityId": "entity_789",
      "entityName": "Bloodfen Raptor",
      "position": 3,
      "attack": 3,
      "health": 2
    },
    "events": [
      {
        "type": "card_played",
        "playerId": "player_123",
        "cardId": "card_001",
        "timestamp": 1640995200000
      },
      {
        "type": "minion_summoned",
        "playerId": "player_123",
        "entityId": "entity_789",
        "timestamp": 1640995200100
      }
    ]
  }
}
```

#### 2.1.4 发起攻击

**接口名称**: 发起攻击  
**接口地址**: `POST /api/v1/games/{gameId}/combat`  
**请求方式**: POST  
**接口描述**: 让随从或英雄攻击目标

**请求参数**:

```json
{
  "playerId": "player_123",
  "attackerId": "entity_789",
  "defenderId": "entity_456"
}
```

**响应参数**:

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "gameId": "game_789",
    "combat": {
      "attacker": {
        "entityId": "entity_789",
        "damage": 3,
        "remainingHealth": 1
      },
      "defender": {
        "entityId": "entity_456",
        "damage": 2,
        "remainingHealth": 0,
        "destroyed": true
      }
    },
    "events": [
      {
        "type": "damage",
        "sourceId": "entity_789",
        "targetId": "entity_456",
        "amount": 3,
        "timestamp": 1640995200000
      },
      {
        "type": "damage",
        "sourceId": "entity_456",
        "targetId": "entity_789",
        "amount": 2,
        "timestamp": 1640995200100
      },
      {
        "type": "entity_destroyed",
        "entityId": "entity_456",
        "timestamp": 1640995200200
      }
    ]
  }
}
```

#### 2.1.5 使用英雄技能

**接口名称**: 使用英雄技能  
**接口地址**: `POST /api/v1/games/{gameId}/hero-power`  
**请求方式**: POST  
**接口描述**: 使用英雄技能

**请求参数**:

```json
{
  "playerId": "player_123",
  "targetId": "entity_456"  // 可选
}
```

**响应参数**:

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "gameId": "game_789",
    "heroPower": {
      "playerId": "player_123",
      "name": "Steady Shot",
      "effect": "Deal 2 damage to the enemy hero",
      "executed": true
    },
    "events": [
      {
        "type": "hero_power_used",
        "playerId": "player_123",
        "timestamp": 1640995200000
      },
      {
        "type": "damage",
        "sourceId": "hero_123",
        "targetId": "hero_456",
        "amount": 2,
        "timestamp": 1640995200100
      }
    ]
  }
}
```

#### 2.1.6 投降

**接口名称**: 投降  
**接口地址**: `POST /api/v1/games/{gameId}/concede`  
**请求方式**: POST  
**接口描述**: 玩家主动投降

**请求参数**:

```json
{
  "playerId": "player_123"
}
```

**响应参数**:

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "gameId": "game_789",
    "status": "ended",
    "winner": "player_456",
    "reason": "concede",
    "events": [
      {
        "type": "game_ended",
        "winner": "player_456",
        "reason": "concede",
        "timestamp": 1640995200000
      }
    ]
  }
}
```

### 2.2 游戏查询接口

#### 2.2.1 获取游戏状态

**接口名称**: 获取游戏状态  
**接口地址**: `GET /api/v1/games/{gameId}`  
**请求方式**: GET  
**接口描述**: 获取当前游戏的完整状态

**请求参数**:
- 无

**响应参数**:

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "gameId": "game_789",
    "status": "in_progress",
    "currentPlayer": "player_123",
    "turn": 5,
    "step": "main_action",
    "players": [
      {
        "id": "player_123",
        "name": "Player1",
        "health": 28,
        "armor": 0,
        "mana": 5,
        "maxMana": 5,
        "overload": 0,
        "handSize": 6,
        "deckSize": 22,
        "minions": [
          {
            "id": "entity_789",
            "name": "Bloodfen Raptor",
            "attack": 3,
            "health": 2,
            "position": 1,
            "canAttack": true
          }
        ],
        "secrets": [],
        "weapons": []
      },
      {
        "id": "player_456",
        "name": "Player2",
        "health": 25,
        "armor": 0,
        "mana": 4,
        "maxMana": 4,
        "overload": 0,
        "handSize": 7,
        "deckSize": 20,
        "minions": [
          {
            "id": "entity_890",
            "name": "Murloc Raider",
            "attack": 2,
            "health": 1,
            "position": 1,
            "canAttack": true
          }
        ],
        "secrets": [],
        "weapons": []
      }
    ]
  }
}
```

#### 2.2.2 获取可用操作

**接口名称**: 获取可用操作  
**接口地址**: `GET /api/v1/games/{gameId}/actions`  
**请求方式**: GET  
**接口描述**: 获取当前玩家可以执行的操作列表

**请求参数**:

```
?playerId=player_123
```

**响应参数**:

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "gameId": "game_789",
    "playerId": "player_123",
    "currentTurn": true,
    "actions": [
      {
        "type": "play_card",
        "cards": [
          {
            "id": "card_003",
            "name": "River Crocolisk",
            "cost": 2,
            "canPlay": true,
            "targets": []
          },
          {
            "id": "card_004",
            "name": "Magma Rager",
            "cost": 3,
            "canPlay": true,
            "targets": []
          }
        ]
      },
      {
        "type": "attack",
        "attackers": [
          {
            "id": "entity_789",
            "name": "Bloodfen Raptor",
            "canAttack": true,
            "targets": [
              {
                "id": "entity_890",
                "name": "Murloc Raider"
              },
              {
                "id": "hero_456",
                "name": "Player2"
              }
            ]
          }
        ]
      },
      {
        "type": "hero_power",
        "canUse": true,
        "targets": [
          {
            "id": "hero_456",
            "name": "Player2"
          }
        ]
      },
      {
        "type": "end_turn",
        "canEnd": true
      }
    ]
  }
}
```

### 2.3 事件订阅接口

#### 2.3.1 WebSocket连接

**接口名称**: WebSocket连接  
**接口地址**: `ws://host:port/ws`  
**协议**: WebSocket  
**接口描述**: 建立实时通信连接

**连接参数**:

```
ws://host:port/ws?token=JWT_TOKEN&gameId=game_789&playerId=player_123
```

**消息格式**:

```json
{
  "type": "game_event",
  "gameId": "game_789",
  "playerId": "player_123",
  "event": {
    "type": "card_played",
    "data": {
      "playerId": "player_123",
      "cardId": "card_001",
      "cardName": "Bloodfen Raptor"
    },
    "timestamp": 1640995200000
  }
}
```

**心跳消息**:

```json
{
  "type": "ping",
  "timestamp": 1640995200000
}
```

```json
{
  "type": "pong",
  "timestamp": 1640995200000
}
```

---

## 3. 内部模块接口

### 3.1 实体管理接口

#### 3.1.1 实体服务接口

```typescript
// 实体管理服务
interface IEntityService {
    /**
     * 创建新实体
     * @param type 实体类型
     * @param attributes 实体属性
     * @returns 创建的实体
     */
    createEntity(type: EntityType, attributes: any): IEntity;
    
    /**
     * 获取实体
     * @param id 实体ID
     * @returns 实体或null
     */
    getEntity(id: EntityId): IEntity | null;
    
    /**
     * 更新实体
     * @param id 实体ID
     * @param updates 更新数据
     */
    updateEntity(id: EntityId, updates: any): void;
    
    /**
     * 销毁实体
     * @param id 实体ID
     */
    destroyEntity(id: EntityId): void;
    
    /**
     * 批量创建实体
     * @param types 实体类型数组
     * @param attributes 实体属性数组
     * @returns 创建的实体数组
     */
    createEntities(types: EntityType[], attributes: any[]): IEntity[];
    
    /**
     * 批量更新实体
     * @param updates 更新数据数组
     */
    updateEntities(updates: { id: EntityId; data: any }[]): void;
    
    /**
     * 获取多个实体
     * @param ids 实体ID数组
     * @returns 实体数组
     */
    getEntities(ids: EntityId[]): IEntity[];
    
    /**
     * 查询实体
     * @param query 查询条件
     * @returns 符合条件的实体数组
     */
    queryEntities(query: EntityQuery): IEntity[];
}

// 实体查询条件
interface EntityQuery {
    type?: EntityType;
    zone?: ZoneType;
    playerId?: PlayerId;
    tags?: { [key: string]: any };
    limit?: number;
    offset?: number;
}
```

#### 3.1.2 实体工厂接口

```typescript
// 实体工厂
interface IEntityFactory {
    /**
     * 创建游戏实体
     * @returns 游戏实体
     */
    createGame(): IGameEntity;
    
    /**
     * 创建玩家实体
     * @param playerId 玩家ID
     * @param name 玩家名称
     * @returns 玩家实体
     */
    createPlayer(playerId: PlayerId, name: string): IPlayerEntity;
    
    /**
     * 创建英雄实体
     * @param heroClass 英雄职业
     * @returns 英雄实体
     */
    createHero(heroClass: HeroClass): IHeroEntity;
    
    /**
     * 创建随从实体
     * @param cardId 卡牌ID
     * @param attributes 随从属性
     * @returns 随从实体
     */
    createMinion(cardId: string, attributes: any): IMinionEntity;
    
    /**
     * 创建法术实体
     * @param cardId 卡牌ID
     * @param attributes 法术属性
     * @returns 法术实体
     */
    createSpell(cardId: string, attributes: any): ISpellEntity;
    
    /**
     * 创建武器实体
     * @param cardId 卡牌ID
     * @param attributes 武器属性
     * @returns 武器实体
     */
    createWeapon(cardId: string, attributes: any): IWeaponEntity;
    
    /**
     * 创建英雄技能实体
     * @param heroPowerId 英雄技能ID
     * @param attributes 技能属性
     * @returns 英雄技能实体
     */
    createHeroPower(heroPowerId: string, attributes: any): IHeroPowerEntity;
    
    /**
     * 创建状态实体
     * @param enchantmentId 状态ID
     * @param target 目标实体
     * @param source 来源实体
     * @param attributes 状态属性
     * @returns 状态实体
     */
    createEnchantment(enchantmentId: string, target: IEntity, source: IEntity, attributes: any): IEnchantmentEntity;
}
```

### 3.2 区域管理接口

#### 3.2.1 区域管理服务

```typescript
// 区域管理服务
interface IZoneService {
    /**
     * 移动实体到指定区域
     * @param entity 要移动的实体
     * @param newZone 目标区域
     * @param newPosition 目标位置（可选）
     * @returns 移动是否成功
     */
    moveEntity(entity: IEntity, newZone: ZoneType, newPosition?: number): boolean;
    
    /**
     * 检查实体是否可以移动到指定区域
     * @param entity 要移动的实体
     * @param newZone 目标区域
     * @returns 是否可以移动
     */
    canMoveToZone(entity: IEntity, newZone: ZoneType): boolean;
    
    /**
     * 获取区域内的实体
     * @param zone 区域类型
     * @param playerId 玩家ID
     * @returns 实体数组
     */
    getZoneEntities(zone: ZoneType, playerId: PlayerId): IEntity[];
    
    /**
     * 获取区域内的实体数量
     * @param zone 区域类型
     * @param playerId 玩家ID
     * @returns 实体数量
     */
    getZoneCount(zone: ZoneType, playerId: PlayerId): number;
    
    /**
     * 获取指定位置的实体
     * @param zone 区域类型
     * @param playerId 玩家ID
     * @param position 位置
     * @returns 实体或null
     */
    getEntityAt(zone: ZoneType, playerId: PlayerId, position: number): IEntity | null;
    
    /**
     * 清空区域
     * @param zone 区域类型
     * @param playerId 玩家ID
     */
    clearZone(zone: ZoneType, playerId: PlayerId): void;
    
    /**
     * 交换两个实体的位置
     * @param entity1 第一个实体
     * @param entity2 第二个实体
     */
    swapPositions(entity1: IEntity, entity2: IEntity): void;
}
```

### 3.3 事件系统接口

#### 3.3.1 事件管理服务

```typescript
// 事件管理服务
interface IEventService {
    /**
     * 触发事件
     * @param event 要触发的事件
     */
    triggerEvent(event: IGameEvent): void;
    
    /**
     * 批量触发事件
     * @param events 要触发的事件数组
     */
    triggerEvents(events: IGameEvent[]): void;
    
    /**
     * 注册扳机
     * @param trigger 要注册的扳机
     */
    registerTrigger(trigger: ITrigger): void;
    
    /**
     * 注销扳机
     * @param triggerId 扳机ID
     */
    unregisterTrigger(triggerId: TriggerId): void;
    
    /**
     * 批量注册扳机
     * @param triggers 扳机数组
     */
    registerTriggers(triggers: ITrigger[]): void;
    
    /**
     * 批量注销扳机
     * @param triggerIds 扳机ID数组
     */
    unregisterTriggers(triggerIds: TriggerId[]): void;
    
    /**
     * 处理事件队列
     */
    processEvents(): void;
    
    /**
     * 清空事件队列
     */
    clearEvents(): void;
    
    /**
     * 获取事件队列
     * @returns 事件队列
     */
    getEventQueue(): IGameEvent[];
    
    /**
     * 暂停事件处理
     */
    pause(): void;
    
    /**
     * 恢复事件处理
     */
    resume(): void;
}

// 事件工厂接口
interface IEventFactory {
    /**
     * 创建伤害事件
     * @param source 来源实体
     * @param target 目标实体
     * @param amount 伤害值
     * @param isSpellDamage 是否为法术伤害
     * @param isCombatDamage 是否为战斗伤害
     * @returns 伤害事件
     */
    createDamageEvent(
        source: IEntity,
        target: IEntity,
        amount: number,
        isSpellDamage?: boolean,
        isCombatDamage?: boolean
    ): IDamageEvent;
    
    /**
     * 创建治疗事件
     * @param source 来源实体
     * @param target 目标实体
     * @param amount 治疗值
     * @returns 治疗事件
     */
    createHealEvent(source: IEntity, target: IEntity, amount: number): IHealEvent;
    
    /**
     * 创建召唤事件
     * @param source 来源实体
     * @param summoned 被召唤的实体
     * @param isPlayed 是否从手牌使用
     * @returns 召唤事件
     */
    createSummonEvent(source: IEntity, summoned: IEntity, isPlayed: boolean): ISummonEvent;
    
    /**
     * 创建死亡事件
     * @param entity 死亡的实体
     * @param wasDestroyed 是否被消灭
     * @param wasSacrificed 是否被牺牲
     * @returns 死亡事件
     */
    createDeathEvent(entity: IEntity, wasDestroyed?: boolean, wasSacrificed?: boolean): IDeathEvent;
    
    /**
     * 创建使用卡牌事件
     * @param player 玩家
     * @param card 使用的卡牌
     * @returns 使用卡牌事件
     */
    createPlayCardEvent(player: IEntity, card: IEntity): IPlayCardEvent;
    
    /**
     * 创建战斗事件
     * @param attacker 攻击者
     * @param defender 防御者
     * @returns 战斗事件
     */
    createCombatEvent(attacker: IEntity, defender: IEntity): ICombatEvent;
}
```

### 3.4 序列系统接口

#### 3.4.1 序列管理服务

```typescript
// 序列管理服务
interface ISequenceService {
    /**
     * 创建序列
     * @param type 序列类型
     * @param context 序列上下文
     * @returns 创建的序列
     */
    createSequence(type: SequenceType, context: any): ISequence;
    
    /**
     * 开始序列
     * @param sequence 要开始的序列
     */
    startSequence(sequence: ISequence): void;
    
    /**
     * 结束当前序列
     */
    endCurrentSequence(): void;
    
    /**
     * 获取当前序列
     * @returns 当前序列或null
     */
    getCurrentSequence(): ISequence | null;
    
    /**
     * 获取下一个序列ID
     * @returns 序列ID
     */
    getNextSequenceId(): number;
    
    /**
     * 暂停当前序列
     */
    pauseCurrentSequence(): void;
    
    /**
     * 恢复当前序列
     */
    resumeCurrentSequence(): void;
    
    /**
     * 取消当前序列
     */
    cancelCurrentSequence(): void;
    
    /**
     * 获取序列队列
     * @returns 序列队列
     */
    getSequenceQueue(): ISequence[];
    
    /**
     * 清空序列队列
     */
    clearSequenceQueue(): void;
}

// 序列工厂接口
interface ISequenceFactory {
    /**
     * 创建卡牌使用序列
     * @param player 玩家
     * @param card 卡牌
     * @param target 目标（可选）
     * @returns 卡牌使用序列
     */
    createPlayCardSequence(player: PlayerId, card: CardEntity, target?: IEntity): IPlayCardSequence;
    
    /**
     * 创建战斗序列
     * @param player 玩家
     * @param attacker 攻击者
     * @param defender 防御者
     * @returns 战斗序列
     */
    createCombatSequence(player: PlayerId, attacker: IEntity, defender: IEntity): ICombatSequence;
    
    /**
     * 创建回合序列
     * @param player 玩家
     * @returns 回合序列
     */
    createTurnSequence(player: PlayerId): ITurnSequence;
    
    /**
     * 创建死亡序列
     * @param entities 死亡的实体
     * @returns 死亡序列
     */
    createDeathSequence(entities: IEntity[]): IDeathSequence;
}
```

### 3.5 光环系统接口

#### 3.5.1 光环管理服务

```typescript
// 光环管理服务
interface IAuraService {
    /**
     * 添加光环
     * @param aura 要添加的光环
     */
    addAura(aura: IAura): void;
    
    /**
     * 移除光环
     * @param auraId 光环ID
     */
    removeAura(auraId: AuraId): void;
    
    /**
     * 更新所有光环
     * @param trigger 更新触发器
     */
    updateAuras(trigger: AuraUpdateTrigger): void;
    
    /**
     * 更新指定实体的光环
     * @param entity 要更新光环的实体
     */
    updateAurasForEntity(entity: IEntity): void;
    
    /**
     * 获取实体的光环
     * @param entityId 实体ID
     * @returns 光环数组
     */
    getAuras(entityId: EntityId): IAura[];
    
    /**
     * 获取光环源
     * @param auraId 光环ID
     * @returns 光环源实体
     */
    getAuraSource(auraId: AuraId): IEntity | null;
    
    /**
     * 检查实体是否受光环影响
     * @param entityId 实体ID
     * @param auraType 光环类型
     * @returns 是否受影响
     */
    isAffectedByAura(entityId: EntityId, auraType: AuraType): boolean;
    
    /**
     * 获取光环优先级
     * @param aura 光环
     * @returns 优先级数值
     */
    getAuraPriority(aura: IAura): number;
    
    /**
     * 排序光环
     * @param auras 光环数组
     * @returns 排序后的光环数组
     */
    sortAuras(auras: IAura[]): IAura[];
}

// 光环工厂接口
interface IAuraFactory {
    /**
     * 创建攻击力光环
     * @param source 来源实体
     * @param value 数值
     * @param condition 条件函数（可选）
     * @returns 攻击力光环
     */
    createAttackAura(source: IEntity, value: number, condition?: (entity: IEntity) => boolean): IAttackAura;
    
    /**
     * 创建生命值光环
     * @param source 来源实体
     * @param value 数值
     * @param condition 条件函数（可选）
     * @returns 生命值光环
     */
    createHealthAura(source: IEntity, value: number, condition?: (entity: IEntity) => boolean): IHealthAura;
    
    /**
     * 创建费用光环
     * @param source 来源实体
     * @param value 数值
     * @param condition 条件函数（可选）
     * @returns 费用光环
     */
    createCostAura(source: IEntity, value: number, condition?: (entity: IEntity) => boolean): ICostAura;
    
    /**
     * 创建关键字光环
     * @param source 来源实体
     * @param keyword 关键字
     * @param condition 条件函数（可选）
     * @returns 关键字光环
     */
    createKeywordAura(source: IEntity, keyword: KeywordType, condition?: (entity: IEntity) => boolean): IKeywordAura;
    
    /**
     * 创建触发器光环
     * @param source 来源实体
     * @param multiplier 倍数
     * @param condition 条件函数（可选）
     * @returns 触发器光环
     */
    createTriggerAura(source: IEntity, multiplier: number, condition?: (entity: IEntity) => boolean): ITriggerAura;
}
```

---

## 4. 数据访问接口

### 4.1 实体仓储接口

```typescript
// 实体仓储接口
interface IEntityRepository {
    /**
     * 保存实体
     * @param entity 要保存的实体
     */
    save(entity: IEntity): void;
    
    /**
     * 根据ID查找实体
     * @param id 实体ID
     * @returns 实体或null
     */
    findById(id: EntityId): IEntity | null;
    
    /**
     * 根据类型查找实体
     * @param type 实体类型
     * @returns 实体数组
     */
    findByType(type: EntityType): IEntity[];
    
    /**
     * 根据区域查找实体
     * @param zone 区域类型
     * @param playerId 玩家ID
     * @returns 实体数组
     */
    findByZone(zone: ZoneType, playerId: PlayerId): IEntity[];
    
    /**
     * 根据条件查询实体
     * @param query 查询条件
     * @returns 实体数组
     */
    findByQuery(query: EntityQuery): IEntity[];
    
    /**
     * 更新实体
     * @param id 实体ID
     * @param updates 更新数据
     */
    update(id: EntityId, updates: any): void;
    
    /**
     * 删除实体
     * @param id 实体ID
     */
    delete(id: EntityId): void;
    
    /**
     * 批量保存实体
     * @param entities 实体数组
     */
    saveAll(entities: IEntity[]): void;
    
    /**
     * 批量更新实体
     * @param updates 更新数据数组
     */
    updateAll(updates: { id: EntityId; data: any }[]): void;
    
    /**
     * 批量删除实体
     * @param ids 实体ID数组
     */
    deleteAll(ids: EntityId[]): void;
    
    /**
     * 统计实体数量
     * @param query 查询条件
     * @returns 实体数量
     */
    count(query?: EntityQuery): number;
    
    /**
     * 检查实体是否存在
     * @param id 实体ID
     * @returns 是否存在
     */
    exists(id: EntityId): boolean;
}

// 游戏状态仓储接口
interface IGameStateRepository {
    /**
     * 保存游戏状态
     * @param state 游戏状态
     */
    save(state: IGameState): void;
    
    /**
     * 根据ID查找游戏状态
     * @param id 游戏ID
     * @returns 游戏状态或null
     */
    findById(id: GameId): IGameState | null;
    
    /**
     * 更新游戏状态
     * @param id 游戏ID
     * @param updates 更新数据
     */
    update(id: GameId, updates: any): void;
    
    /**
     * 删除游戏状态
     * @param id 游戏ID
     */
    delete(id: GameId): void;
    
    /**
     * 创建游戏快照
     * @param id 游戏ID
     * @returns 游戏快照
     */
    createSnapshot(id: GameId): GameSnapshot;
    
    /**
     * 恢复快照
     * @param snapshot 游戏快照
     * @returns 游戏状态
     */
    restoreSnapshot(snapshot: GameSnapshot): IGameState;
    
    /**
     * 获取活跃游戏
     * @returns 活跃游戏状态数组
     */
    findActiveGames(): IGameState[];
    
    /**
     * 获取已完成游戏
     * @param limit 限制数量
     * @returns 已完成游戏状态数组
     */
    findCompletedGames(limit?: number): IGameState[];
}

// 事件仓储接口
interface IEventRepository {
    /**
     * 保存事件
     * @param event 事件
     */
    save(event: IGameEvent): void;
    
    /**
     * 批量保存事件
     * @param events 事件数组
     */
    saveAll(events: IGameEvent[]): void;
    
    /**
     * 根据游戏ID查找事件
     * @param gameId 游戏ID
     * @returns 事件数组
     */
    findByGameId(gameId: GameId): IGameEvent[];
    
    /**
     * 根据实体ID查找事件
     * @param entityId 实体ID
     * @returns 事件数组
     */
    findByEntityId(entityId: EntityId): IGameEvent[];
    
    /**
     * 根据事件类型查找事件
     * @param eventType 事件类型
     * @returns 事件数组
     */
    findByEventType(eventType: EventType): IGameEvent[];
    
    /**
     * 根据时间范围查找事件
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @returns 事件数组
     */
    findByTimeRange(startTime: number, endTime: number): IGameEvent[];
    
    /**
     * 根据条件查询事件
     * @param query 查询条件
     * @returns 事件数组
     */
    findByQuery(query: EventQuery): IGameEvent[];
}
```

### 4.2 缓存接口

```typescript
// 缓存接口
interface ICache {
    /**
     * 获取缓存值
     * @param key 键
     * @returns 值或null
     */
    get(key: string): any | null;
    
    /**
     * 设置缓存值
     * @param key 键
     * @param value 值
     * @param ttl 过期时间（秒）
     */
    set(key: string, value: any, ttl?: number): void;
    
    /**
     * 删除缓存
     * @param key 键
     */
    delete(key: string): void;
    
    /**
     * 清空缓存
     */
    clear(): void;
    
    /**
     * 检查键是否存在
     * @param key 键
     * @returns 是否存在
     */
    has(key: string): boolean;
    
    /**
     * 获取剩余过期时间
     * @param key 键
     * @returns 剩余时间（秒）
     */
    getTTL(key: string): number;
    
    /**
     * 设置过期时间
     * @param key 键
     * @param ttl 过期时间（秒）
     */
    setTTL(key: string, ttl: number): void;
}

// LRU缓存接口
interface ILRUCache extends ICache {
    /**
     * 获取缓存大小
     * @returns 缓存大小
     */
    size(): number;
    
    /**
     * 获取缓存最大容量
     * @returns 最大容量
     */
    maxSize(): number;
    
    /**
     * 获取缓存命中率
     * @returns 命中率
     */
    hitRate(): number;
    
    /**
     * 获取缓存未命中率
     * @returns 未命中率
     */
    missRate(): number;
}
```

---

## 5. 错误处理

### 5.1 错误码定义

| 错误码 | 错误消息 | 说明 |
|--------|----------|------|
| 200 | OK | 请求成功 |
| 201 | Created | 资源创建成功 |
| 400 | Bad Request | 请求参数错误 |
| 401 | Unauthorized | 未授权 |
| 403 | Forbidden | 禁止访问 |
| 404 | Not Found | 资源不存在 |
| 409 | Conflict | 资源冲突 |
| 422 | Unprocessable Entity | 请求格式正确但语义错误 |
| 429 | Too Many Requests | 请求过于频繁 |
| 500 | Internal Server Error | 服务器内部错误 |
| 503 | Service Unavailable | 服务不可用 |

### 5.2 错误响应格式

```json
{
  "code": 400,
  "message": "Invalid request parameters",
  "errors": [
    {
      "field": "playerId",
      "message": "Player ID is required",
      "code": "REQUIRED_FIELD"
    },
    {
      "field": "cardId",
      "message": "Card not found in hand",
      "code": "INVALID_CARD"
    }
  ],
  "timestamp": 1640995200000,
  "requestId": "req_123456"
}
```

### 5.3 异常类型

```typescript
// 基础异常
class GameException extends Error {
    constructor(message: string, code: string, statusCode: number);
}

// 游戏逻辑异常
class GameLogicException extends GameException {
    constructor(message: string, code: string);
}

// 实体异常
class EntityException extends GameException {
    constructor(message: string, entityId: EntityId);
}

// 区域异常
class ZoneException extends GameException {
    constructor(message: string, zone: ZoneType);
}

// 事件异常
class EventException extends GameException {
    constructor(message: string, eventType: EventType);
}

// 序列异常
class SequenceException extends GameException {
    constructor(message: string, sequenceType: SequenceType);
}
```

---

## 6. 性能指标

### 6.1 响应时间

| 接口类型 | 目标响应时间 | 说明 |
|----------|--------------|------|
| 游戏控制接口 | < 100ms | 用户操作响应时间 |
| 游戏查询接口 | < 50ms | 状态查询响应时间 |
| 事件处理 | < 50ms | 事件处理时间 |
| WebSocket消息 | < 20ms | 实时消息延迟 |

### 6.2 吞吐量

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 并发游戏数 | 10,000 | 同时进行的游戏数量 |
| 每秒事件数 | 100,000 | 事件处理能力 |
| 每秒API调用 | 50,000 | API处理能力 |

### 6.3 资源使用

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 内存使用 | < 50MB/游戏 | 单局游戏内存占用 |
| CPU使用 | < 30% | 游戏进行时CPU占用 |
| 网络带宽 | < 1MB/s | 网络传输速率 |

---

## 7. 版本管理

### 7.1 版本策略

- **主版本号**: 不兼容的API变更
- **次版本号**: 向下兼容的功能性新增
- **修订号**: 向下兼容的问题修正

### 7.2 版本兼容性

- 主版本升级：不保证向后兼容
- 次版本升级：保证向后兼容
- 修订号升级：完全向后兼容

### 7.3 版本迁移

- 提供版本迁移指南
- 支持平滑升级
- 提供回滚机制

---

## 8. 测试接口

### 8.1 测试控制接口

```typescript
// 测试控制接口
interface ITestController {
    /**
     * 创建测试游戏
     * @param config 测试配置
     * @returns 游戏ID
     */
    createTestGame(config: TestGameConfig): GameId;
    
    /**
     * 执行测试步骤
     * @param gameId 游戏ID
     * @param steps 测试步骤
     */
    executeTestSteps(gameId: GameId, steps: TestStep[]): void;
    
    /**
     * 验证游戏状态
     * @param gameId 游戏ID
     * @param expectedState 期望状态
     * @returns 验证结果
     */
    verifyGameState(gameId: GameId, expectedState: any): boolean;
    
    /**
     * 获取测试报告
     * @param gameId 游戏ID
     * @returns 测试报告
     */
    getTestReport(gameId: GameId): TestReport;
    
    /**
     * 执行性能测试
     * @param scenario 测试场景
     * @returns 性能测试结果
     */
    runPerformanceTest(scenario: PerformanceScenario): PerformanceTestResult;
}
```

### 8.2 调试接口

```typescript
// 调试接口
interface IDebugController {
    /**
     * 获取游戏日志
     * @param gameId 游戏ID
     * @returns 游戏日志
     */
    getGameLogs(gameId: GameId): GameLog[];
    
    /**
     * 获取实体状态
     * @param gameId 游戏ID
     * @param entityId 实体ID
     * @returns 实体详细状态
     */
    getEntityDebugInfo(gameId: GameId, entityId: EntityId): EntityDebugInfo;
    
    /**
     * 获取事件流
     * @param gameId 游戏ID
     * @returns 事件流
     */
    getEventStream(gameId: GameId): EventStream;
    
    /**
     * 创建状态快照
     * @param gameId 游戏ID
     * @returns 快照ID
     */
    createSnapshot(gameId: GameId): SnapshotId;
    
    /**
     * 恢复快照
     * @param snapshotId 快照ID
     * @returns 是否成功
     */
    restoreSnapshot(snapshotId: SnapshotId): boolean;
}
```

---

## 9. 附录

### 9.1 数据类型定义

```typescript
// 基础类型
type EntityId = string;
type PlayerId = string;
type GameId = string;
type CardId = string;
type TriggerId = string;
type AuraId = string;
type SnapshotId = string;

// 枚举类型
enum EntityType {
    GAME = 'GAME',
    PLAYER = 'PLAYER',
    HERO = 'HERO',
    MINION = 'MINION',
    SPELL = 'SPELL',
    WEAPON = 'WEAPON',
    HERO_POWER = 'HERO_POWER',
    ENCHANTMENT = 'ENCHANTMENT'
}

enum ZoneType {
    PLAY = 'PLAY',
    HAND = 'HAND',
    DECK = 'DECK',
    GRAVEYARD = 'GRAVEYARD',
    SECRET = 'SECRET',
    SETASIDE = 'SETASIDE',
    REMOVEDFROMGAME = 'REMOVEDFROMGAME'
}

enum EventType {
    DAMAGE = 'DAMAGE',
    HEAL = 'HEAL',
    SUMMON = 'SUMMON',
    DEATH = 'DEATH',
    PLAY_CARD = 'PLAY_CARD',
    COMBAT = 'COMBAT',
    TURN_START = 'TURN_START',
    TURN_END = 'TURN_END'
}

enum SequenceType {
    PLAY_CARD = 'PLAY_CARD',
    COMBAT = 'COMBAT',
    TURN = 'TURN',
    DEATH = 'DEATH'
}

enum AuraType {
    ATTACK = 'ATTACK',
    HEALTH = 'HEALTH',
    COST = 'COST',
    KEYWORD = 'KEYWORD',
    TRIGGER_MULTIPLIER = 'TRIGGER_MULTIPLIER'
}
```

### 9.2 错误码对照表

见5.1错误码定义

### 9.3 常见问题

**Q: 如何处理网络超时？**
A: 设置合理的超时时间，并实现重试机制。

**Q: 如何处理并发请求？**
A: 使用锁机制或乐观锁来处理并发。

**Q: 如何优化性能？**
A: 使用缓存、批量处理、异步操作等方式优化。

**Q: 如何保证数据一致性？**
A: 使用事务、事件溯源、最终一致性等模式。

---

**文档结束**

**签署页**:
- 接口设计师: _______________ 日期: _______________
- 技术负责人: _______________ 日期: _______________
- 开发负责人: _______________ 日期: _______________
